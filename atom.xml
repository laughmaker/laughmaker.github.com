<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[闻竹]]></title>
  <link href="http://makeLaugh.github.io/atom.xml" rel="self"/>
  <link href="http://makeLaugh.github.io/"/>
  <updated>2014-05-15T17:16:10+08:00</updated>
  <id>http://makeLaugh.github.io/</id>
  <author>
    <name><![CDATA[makeLaugh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[善用Xcode，提高开发效率]]></title>
    <link href="http://makeLaugh.github.io/blog/2014/05/11/shan-yong-xcode%2Cti-gao-kai-fa-xiao-lu/"/>
    <updated>2014-05-11T21:53:08+08:00</updated>
    <id>http://makeLaugh.github.io/blog/2014/05/11/shan-yong-xcode,ti-gao-kai-fa-xiao-lu</id>
    <content type="html"><![CDATA[<p>　　默认的xcode其实已经很强大的了，用起来已经很贴心舒服了，但它还可以更加强大的，以下介绍下我自己的一些增强技巧。</p>

<p>　　<strong>一、配色</strong><br />
　　要提高效率，首先得看着舒服，是吧。默认的白色，平常使用其实也挺不错的了，但时间用长了，还是感觉有一些不舒服，它最大的问题是色彩对比不明显，不容易定位到关键词上去。我差不多是使用默认配色一年多后，才打算改换主题的，后来在网上下了很多别人的主题，都发觉要么是对比度太强烈了，看着刺眼，或者太花哨，或者太死板，都有一些不喜欢的地方。后来找到了一个相对比较喜欢的主题，这个主题是仿sublime的一个主题<a href="https://github.com/colinta/zenburn">zenburn</a> ，但还是有一些不太喜欢的地方，后来花了一整个下午，根据它调了一个主题，包括字体、背景色、关键词颜色等等，算是比较满意了，<a href="https://github.com/makeLaugh/xcodeTheme">下载链接</a>在这里，喜欢的拿走。<br />
　　安装方式：下载后，将主题文件放入<code>/Users/HZD/Library/Developer/Xcode/UserData/FontAndColorThemes </code>目录中，重启<code>xcode即可</code>。我的环境是xcode5.1，其它的未测试。</p>

<p>    <strong>二、CocoaPods</strong><br />
    对CocoaPods的介绍和安装教程网太多了，随便百度谷歌一下都满大街了，我想说，如果还没有使用它来管理毓三方库的，那得切换了，因为它实在是太简单太高效了。下面简单罗列一下使用步骤。 <a href="http://code4app.com/article/cocoapods-install-usage">详细参考教程</a></p>

<ul>
  <li>
    <p>更换ruby源，以加快安装速度，如果已经更换过的跳过：</p>

    <pre><code>  1. gem sources --remove https://rubygems.org/
  2. gem sources -a http://ruby.taobao.org/
  3. gem sources -l //查看新的镜像源
</code></pre>
  </li>
  <li>
    <p>安装ruby，一般mac都自带了ruby，若未安装，可用以下方式安装或更新到最新版  </p>

    <pre><code>  1. 安装RVM：curl -L https://get.rvm.io | bash -s stable --ruby
  2. 列出已知的ruby版本：rvm list known
  3. 安装最新的版本：rvm install version号
  4. 切换到安装的版本上：rvm use version号
  5. rvm rubygems latest
</code></pre>
  </li>
  <li>
    <p>安装和使用CocoaPods</p>

    <pre><code>  1. 安装CocoaPods：sudo gem install cocoapods
  2. 搜索要使用的库：pod search AFNetworking，会得到如何使用、源地址等提示
  3. 编辑配置文件：vim Podfile
  4. 按上术提示，添加相关配置，并保存  
     platform :ios, '7.0'  
     pod "AFNetworking", "~&gt; 2.0"
  5. 安装第三方库：pod install 
  6. 以后打开项目都打开`.xcworkspace`文件，而不是源来的项目文件。
</code></pre>
  </li>
</ul>

<p>    就这样，安装完成了，以后就可以使用AFNetworking了。
    一个技巧：有时候，第三方库会有警告，为了忽略警告，只需要在Podfile文件中添加一个命令即可，<code>inhibit_all_warnings!</code>。
    以下我的Podfile配置文件作为一个参考：  </p>

<pre><code>platform :ios, '7.0'
inhibit_all_warnings!
pod 'MKNetworkKit'
pod 'FMDB', '~&gt; 2.2'
pod 'REFrostedViewController', '~&gt; 2.4.5'
pod 'BlocksKit'
pod 'Overline-BlocksKit'
pod 'Masonry'
pod 'AFNetworking', '~&gt; 2.2.3'
pod 'UIColor+CSSColors', '~&gt; 0.0.1'
pod 'BlurryModalSegue', '~&gt; 1.0.0'
pod 'SBAPNSPusher', '~&gt; 2.2.1'!
</code></pre>

<p>    伏笔，CocoaPod其实有更便捷的管理方式，见以下插件部分。</p>

<p>    <strong>三、插件</strong><br />
    Xcode已经是一个非常强大的IDE了，但是，它还可以更强大，这就需要外挂了。<br />
    首先，安装插件管理器，当然你也可以手动来管理，但是强列推荐使用它<a href="https://github.com/supermarin/Alcatraz"><strong>Alcatraz</strong></a>，有了它，你的xcode将无所不能，且极其的方便管理插件，安装卸载，一键搞定。详细教程，点开链接后仔细阅读吧，以下简单说明安装和卸载：<br />
    <strong>安装</strong>：curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh<br />
    或者下载源码编译即可<br />
    <strong>重启xcode</strong>，即可安装好<br />
    <strong>卸载</strong>：我还没有卸载过，你要不喜欢，运行下面的命令吧  </p>

<pre><code>卸载Alcatraz: rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin
卸载通过它安装的插件: rm -rf ~/Library/Application\ Support/Alcatraz/
</code></pre>

<p>    启动Alcatraz：<code>command+shift+9</code>或者window-&gt;Package Manager<br />
    它有四个菜单，分别为<strong>All 插件  主题  模板</strong>，点击单个插件前面的小图标时，会自动安装，安装成功后，注意看图标，变成了淡蓝色(注意睁大眼睛看)，卸载再点一次即可，更新再点一次就是更新了。</p>

<p>    网上已经有了各种排名的xcode的十大插件、十五大插件的，试用了一下，下面简单介绍几个个人使用后，觉得挺不错的插件：  </p>

<p>    1.<strong>CocoaPods</strong><br />
    不喜欢使用命令行？没关系，装上这个插件，在Product选项里，就集成了CocoaPods选项了，直接点击就可以在Xcode里管理CocoaPods里的第三方库了。<br />
    <img src="https://github.com/kattrali/cocoadocs-xcode-plugin/raw/master/menu.png" alt="image" /></p>

<p>    2.<strong>ColorSense</strong><br />
    是不是每次设置颜色的时候，不知道效果？用它吧，直接在代码里修改颜色，如下图：  <br />
	<img src="images/blog/2014/Xcode效率/ColorSense.png" alt="image" /></p>

<p>    3.<strong>VVDocumenter</strong><br />
    注释对于代码很重要，特别是对代码规范要求很严的公司，那更是必须写的，话说，自己写，有一个好的规范不也挺好的么，这个配合<code>appledoc</code>一起工作，简直是神器，下面有介绍。这货可以让你在写注释的时候，大幅的降低繁杂重复的工作量。见下图：<br />
    <img src="http://www.cocoachina.com/cms/uploads/allimg/130918/4196_130918173834_1.gif" alt="image" /></p>

<p>    4.<strong>FuzzyAutocomplete</strong><br />
    xcode自带的自动代码匹配功能不是很完善，当你只大概记得一个方法时，这时候，xcode就无能为力了，它登场了，效果见下图：<br />
    <img src="http://www.cocoachina.com/cms/uploads/allimg/131031/4196_131031114351_1.gif" alt="image" /></p>

<p>    5.<strong>XAlign</strong><br />
    你有没有一个空格一个空格的敲，就为了对齐那该死的<code>@、=、*</code>等符号？好吧，如果你没有，那说明你没有代码洁癖，我应该恭喜你呢，还是替后来维护的人难受？<br />
    <img src="http://www.cocoachina.com/cms/uploads/allimg/131211/4196_131211113618_1.gif" alt="image" /></p>

<p>    6.<strong>BBUDebuggerTuckAway</strong><br />
    xcode很强大，但有的时候，它却不太讨人喜欢，我明明在编写代码了，调试窗口却死活不肯退场，死占着那个位置，让我多难受啊。好吧，我开始写代码了，你去睡一会儿吧。<br />
    <img src="http://cms.csdnimg.cn/article/201405/05/53674c667516f.jpg" alt="image" /></p>

<p>    7.<strong>XcodeBoost</strong><br />
    它的使用有一点小复杂，你需要花一点时间去熟悉它，了解它😃，别恐惧，其实也没有那么复杂了，它真的很强大，真的非常的强大，我还是先上图吧<br />
    <img src="https://github.com/fortinmike/XcodeBoost/raw/master/Images/highlighting.gif" alt="image" /><br />
    <img src="https://github.com/fortinmike/XcodeBoost/raw/master/Images/copy-method-declarations.gif" alt="image" /><br />
    <img src="https://github.com/fortinmike/XcodeBoost/raw/master/Images/paste-without-reindent.gif" alt="image" />  </p>

<p>    8.<strong>KSImagedNamed</strong>
    当我第一次看到它的时候，我内牛满面，我为什么不早点认识它呢，以前在代码里设置图片，不知道图片是什么样子，也不知道图片是什么名字的时候，在UI给我的图片包里，一个一个去找的时候，我有想疯了的感觉。这货不但可以自动匹配识别图片名字，还能预览图片，你还有什么理由不使用它呢？
    <img src="http://cms.csdnimg.cn/article/201405/05/53673f77a65a3.jpg" alt="image" />
    
    以上是我使用过后，感觉非常不错，能够极大提高效率的几个插件，以后有新的体验了，还会更新，这些插件都可以直接通过<code>Alcatraz</code>来管理，所以不上链接了。</p>

<p>    <strong>四、文档生成工具Appledoc</strong><br />
    前面介绍了<code>VVDocumenter</code>，终于轮到它登场了，使用<code>VVDocumenter</code>写上标准的注释，然后使用appledoc，一键生成苹果官方式的文档，如下图所示：<br />
	<img src="images/blog/2014/Xcode效率/appledoc1.png" alt="image" /><br />
    首先安装，可以选择正常安装，也可以选择homebrew安装。<br />
    <strong>正常安装</strong>：  </p>

<pre><code>1. git clone git://github.com/tomaz/appledoc.git
2. cd ./appledoc
3. sudo sh install-appledoc.sh
</code></pre>

<p>    <strong>homeBrew安装</strong>：  </p>

<pre><code>brew install appledoc
</code></pre>

<p>    <strong>使用：</strong>  </p>

<pre><code>1. cd 项目目录
2.appledoc -o ./doc --project-name MyProject --project-company MyCompany --company-id companyId .
</code></pre>

<p>    首先进入项目目录，然后运行上面的命令，<code>MyProject</code>是你项目的名字，<code>MyCompany</code>是你公司的名字，最后<code>./doc</code>是指在当前目录下，生成一个doc目录，里面有一个<code>docset-installed.txt</code>文件，里面记录你安装的记录和文档生成的路径，<code>companyId</code>一般写成<code>com.company</code>格式。<br />
    appledoc支持markdown、html等语言来写注释，详细的介绍推荐看<a href="http://blog.ibireme.com/2013/08/26/appledoc-guide/">这篇文章</a></p>

<p>    <strong>总结：</strong><br />
    Xcode虽然是苹果一家开发维护，封闭的，但是在配合一些其它的工具，还是可以极大的提高我们的开发效率，工欲善其事，必先利其器，好好的挖掘它的潜力，为我们服务！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git简单实用操作]]></title>
    <link href="http://makeLaugh.github.io/blog/2014/05/11/gitjian-dan-shi-yong-cao-zuo/"/>
    <updated>2014-05-11T12:00:04+08:00</updated>
    <id>http://makeLaugh.github.io/blog/2014/05/11/gitjian-dan-shi-yong-cao-zuo</id>
    <content type="html"><![CDATA[<p><strong>总则：</strong>  </p>

<pre><code>1.多使用分支操作，体会git强大的分支功能。
2.在创建代码仓库的时候，默认会创建一个master分支，这个分支做为一个稳定分支，只合并稳定的代码。
3.另外创建一个dev分支，这个分支做为日常的开发测试使用，dev分支测试稳家后，方合并到master分支去。
4.如果需要开发计划外的功能时，可基于当前的开发分支，创建一个feature分支，完成后如果需要则合并到dev分支，如无需再使用则可删除。
5.如果遇到bug需要紧急修复，则可基于master分支创建fixed分支，修复完成测试通过，则合并到master分支，删除fixed分支。
</code></pre>

<p><strong>本地操作</strong></p>

<ul>
  <li>初始化：git init</li>
  <li>添加所有修改文件到git仓库：git add -A</li>
  <li>添加某单个文件到git仓库：git add 文件件</li>
  <li>确认修改内容：git commit -m “修改内容叙述”</li>
</ul>

<p><strong>与服务器相连</strong></p>

<ul>
  <li>克隆一个仓库：git clone 远端地址</li>
  <li>查看连接的远端地址：git remote -v</li>
  <li>连接到远端服务器：git remote add origin 远端地址</li>
  <li>与远端服务器断开连接：git remote rm origin</li>
  <li>将远端代码合并到本地：git pull origin master</li>
  <li>将本地代码上传到远端服务器：git push origin master</li>
</ul>

<p><strong>分支与合并</strong></p>

<ul>
  <li>查看分支：git branch -a</li>
  <li>基于当前分支创建分支并切换到新的分支：git checkout -b 分支名</li>
  <li>当前在master分支，将dev分支合并到master：git merge dev</li>
  <li>删除本地分支：git branch -d 分支名</li>
  <li>删除远端分支：
    <ul>
      <li>1.git push origin –delete 分支名  </li>
      <li>2.git push origin :分支名 //用空分支覆盖远端分支方式 </li>
    </ul>
  </li>
  <li>克隆远端某个分支：git checkout –track -b foobar origin/foobar</li>
  <li>提交本地的test分支到远端的master分支：git push origin test:master</li>
  <li>提交本地的test分支作为远端的test分支：git push origin test:test</li>
</ul>

<p><strong>查看状态</strong></p>

<ul>
  <li>查看当前哪些文件更改了而没有添加到仓库跟踪：git status</li>
  <li>查看历史提交记录：git log</li>
</ul>

<p><strong>版本回溯</strong></p>

<p>  <em>为了安全起见，最好基于所在分支创建一个分支，回到历史版本，找到需要的代码，然后再删除该分支。</em></p>

<ul>
  <li>在当前分支新建分支：git checkout -b 分支名</li>
  <li>查看历史提交记录，找到提交记录id：git log</li>
  <li>回到需要的历史版本：git checkout commitId</li>
  <li>找到需要的代码，复制出来，切换回原分支，删除该分支</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[centos6.5配置nginx+php+mongo服务器环境]]></title>
    <link href="http://makeLaugh.github.io/blog/2014/05/09/centos6-dot-4pei-zhi-nginx-plus-php-plus-mongofu-wu-qi-huan-jing/"/>
    <updated>2014-05-09T13:56:34+08:00</updated>
    <id>http://makeLaugh.github.io/blog/2014/05/09/centos6-dot-4pei-zhi-nginx-plus-php-plus-mongofu-wu-qi-huan-jing</id>
    <content type="html"><![CDATA[<p>首先系统安装完成后，执行：<code>yum -y update</code> 命令，升级补丁。</p>

<hr />

<h2 id="php54">安装PHP5.4</h2>

<p><a href="http://www.iitshare.com/centeros-6-3-64-bit-install-php-5-4-3.html">参考教程</a></p>

<p><strong>1.安装支持套件</strong></p>

<pre><code>yum -y install gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers
</code></pre>

<p><strong>2.安装支持库</strong></p>

<ul>
  <li><a href="http://pan.baidu.com/share/link?shareid=2787262895&amp;uk=553700327&amp;fid=2190701233">pcre-8.30.tar.gz下载</a></li>
  <li><a href="http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gz">libiconv-1.14.tar.gz下载</a></li>
  <li><a href="http://centos.googlecode.com/files/libmcrypt-2.5.8.tar.gz">libmcrypt-2.5.8.tar.gz下载</a></li>
  <li><a href="http://nchc.dl.sourceforge.net/project/mhash/mhash/0.9.9.9/mhash-0.9.9.9.tar.gz">mhash-0.9.9.9.tar.gz下载</a></li>
  <li>
    <p><a href="http://nchc.dl.sourceforge.net/project/mcrypt/MCrypt/2.6.8/mcrypt-2.6.8.tar.gz">mcrypt-2.6.8.tar.gz下载</a></p>

    <pre><code> 安装方法：
 tar zxvf 文件名.tar.gz
 cd 文件夹
 ./configure
 make install
</code></pre>
  </li>
</ul>

<p><strong>备注：</strong></p>

<pre><code>配置mcrypt-2.6.8.tar.gz支持库时出现以下错误
configure: error: *** libmcrypt was not found
解决方法
运行 export LD_LIBRARY_PATH=/usr/local/lib: LD_LIBRARY_PATH
然后编译执行

# ./configure
# make
# make install
</code></pre>

<p><strong>3.安装PHP5.4</strong></p>

<p><strong><a href="http://am1.php.net/get/php-5.4.26.tar.gz/from/this/mirror">下载地址</a></strong></p>

<p><strong>安装方法：</strong></p>

<pre><code>tar jvxf php-5.4.26.tar.gz
cd php-5.4.26
./configure -prefix=/usr/local/php -with-config-file-path=/usr/local/php/etc -with-iconv-dir=/usr/local/lib -with-freetype-dir -with-jpeg-dir -with-png-dir -with-zlib -with-libxml-dir=/usr -enable-xml -disable-rpath -enable-bcmath -enable-inline-optimization -with-curl -with-curlwrappers -enable-fpm -enable-mbstring -with-mcrypt -with-gd -enable-gd-native-ttf -with-openssl -with-mhash -enable-pcntl -enable-sockets -with-xmlrpc -enable-soap -without-pear -with-fpm-user=www -with-fpm-group=www --disable-fileinfo
make
make install
</code></pre>

<p><strong>备注：</strong></p>

<ul>
  <li>若./configure…时，报：<code>configure: error: Cannot find ldap libraries in /usr/lib</code>错误，则执行：<code>cp -frp /usr/lib64/libldap* /usr/lib/</code> 命令，再<code>./configure</code></li>
  <li>若make时报<code>make: *** [sapi/cli/php] Error 1</code>错误，则执行：先<code>make clean</code>后 再<code>make ZEND_EXTRA_LIBS='-liconv'</code> 命令</li>
  <li>若<code>make ZEND_EXTRA_LIBS='-liconv'</code>时报<code>make: *** [ext/phar/phar.php] 错误 127</code>，则。。。</li>
  <li>最后make install</li>
</ul>

<p><strong>添加配置文件：</strong></p>

<p>在安装文件目录，执行以下命令：</p>

<ul>
  <li>cp php.ini-production /usr/local/php/lib/php.ini</li>
  <li>cp php.ini-production /usr/local/php/etc/php.ini</li>
  <li>cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf</li>
</ul>

<p>编辑php-fpm.conf文件为以下内容：</p>

<pre><code>[global]
pid = run/php-fpm.pid
error_log = log/php-fpm.log
log_level = notice
[www]
listen = 127.0.0.1:9000
user = www
group = www
pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3
pm.max_requests = 500
</code></pre>

<p>测试php-fpm配置：</p>

<pre><code>/usr/local/php/sbin/php-fpm -t
如果显示以下信息，则说明安装成功
NOTICE: configuration file /usr/local/php/etc/php-fpm.conf test is successful
</code></pre>

<p>启动9000端口号</p>

<pre><code>防火墙中开启php默认的端口号9000，如果服务器没有开启防火墙，则不需要
</code></pre>

<p>启动php-fpm：</p>

<pre><code>/usr/local/php/sbin/php-fpm
如果启动报错：ERROR: [pool www] cannot get uid for user ‘www’
增加用户即可,具体的代码：useradd www -M -s /sbin/nologin
</code></pre>

<hr />

<h2 id="nginx">安装NGINX</h2>

<p><a href="http://nginx.org/packages/centos/6/x86_64/RPMS/nginx-1.4.6-1.el6.ngx.x86_64.rpm">下载地址</a></p>

<p><a href="http://nginx.org/packages/centos/6/x86_64/RPMS/nginx-1.4.6-1.el6.ngx.x86_64.rpm">nginx官方源库</a>：可以找寻其他版本</p>

<p>安装：</p>

<pre><code>rpm -ivh nginx-release-centos-6-0.el6.ngx.noarch.rpm
</code></pre>

<hr />

<h2 id="mongodb">安装Mongodb</h2>

<p><strong>1.添加yum源：</strong></p>

<pre><code>vi /etc/yum.repos.d/10gen.repo
添加以下语句：

[10gen] 
name=10gen Repository 
baseurl=http://downloads-distro.mongodb.org/repo/redhat/os/x86_64 
gpgcheck=0 
</code></pre>

<p><strong>2.安装MongoDB的服务器端和客户端工具：</strong></p>

<pre><code>yum install mongo-10gen-server
yum install mongo-10gen
</code></pre>

<p>3.更新Mongodb：</p>

<pre><code>停掉mongodb，执行
yum update mongo-10gen mongo-10gen-server
</code></pre>

<p>备注：也可到<a href="http://downloads-distro.mongodb.org/repo/redhat/os/x86_64">这里</a>下载最新版，手动<code>yum -ivh ...</code>安装。需要先安装mongo-10gen，再安装mongo-10gen-server。</p>

<p>启动Mongodb：service mongod start</p>

<hr />

<p><strong>以上将三个库都安装完成了，下面需要装三个关联起来。</strong></p>

<p><strong>首先配置NGINX，支持PHP解析</strong></p>

<p>1.打开/etc/nginx/conf.d目录下的default.conf文件。<br />
2.如下代码所示，将<code>location</code> 中的相关路径保持一致，差添加index.php解析</p>

<pre><code>server {
listen       80;
server_name  localhost;

#charset koi8-r;
#access_log  /var/log/nginx/log/host.access.log  main;

location / {
    root   /usr/share/nginx/html;
    index  index.php index.html index.htm;
}

#error_page  404              /404.html;

# redirect server error pages to the static page /50x.html
#
error_page   500 502 503 504  /50x.html;
location = /50x.html {
    root   /usr/share/nginx/html;
}

# proxy the PHP scripts to Apache listening on 127.0.0.1:80
#
#location ~ \.php$ {
#    proxy_pass   http://127.0.0.1;
#}

# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
#
location ~ \.php$ {
    root           /usr/share/nginx/html;
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    fastcgi_param  SCRIPT_FILENAME  /usr/share/nginx/html$fastcgi_script_name;
    include        fastcgi_params;
}

# deny access to .htaccess files, if Apache's document root
# concurs with nginx's one
#
#location ~ /\.ht {
#    deny  all;
#}
</code></pre>

<h5 id="phpmongodb">安装PHP对Mongodb的驱动</h5>

<p>1.<strong><a href="http://github.com/mongodb/mongo-php-driver">下载驱动</a></strong></p>

<p>2.<strong>解压，并进入到该目录。</strong></p>

<p>3.执行以下命令：</p>

<pre><code>phpize		或者  /usr/local/php/bin/phpize 
./configure	或者  ./configure  --with-php-config=/usr/local/php/bin/php-config --with-mongodb 
make all
sudo make install
</code></pre>

<p>4.编辑php配置文件，添加对mongodb的支持</p>

<pre><code>vim /usr/local/php/etc/php.ini

在最后添加如下代码：

extension=mongo.so

保存退出
</code></pre>

<h5 id="mongodb-administrator">安装MongoDB Administrator</h5>

<p>1.<a href="http://rockmongo.com/downloads">下载地址</a></p>

<p>2.将文件解压到 <code>/usr/share/nginx/html</code> 文件夹里</p>

<p>3.在浏览器里打开：http://localhost/rockmongo/index.php</p>

<p>4.初始密码：admin admin</p>

<p>5.若添加管理员后，去除默认管理员，需要打开rockmogo里的配置文件，将其中一行改为：</p>

<pre><code>vim /usr/share/nginx/html/rockmongo/config.php

$MONGO["servers"][$i]["mongo_auth"] = true;//enable mongo authentication?
</code></pre>

<hr />

<p>至此，已全部配置完毕，在配置完成后，需要重新启动服务。</p>

<p><strong>以下是几个常用命令</strong></p>

<pre><code>* 启动NGINX：service nginx start
* 停步NGINX：service nginx stop
* 重启NGINX：service nginx reload


* 启动PHP： /usr/local/php/sbin/php-fpm
* 停止PHP：killall -9 php-fpm

* 启动Mongo：service mongod start
* 停止Mongo：service mongod stop
</code></pre>

<p><strong>相关配置文件所在目录：</strong></p>

<pre><code>* nginx 配置文件目录：/etc/nginx/*.conf
* php配置文件目录：/usr/local/php/etc/php.ini
* 网页文件目录：/usr/share/nginx/html 
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MKNetworkEngine的一层小封装]]></title>
    <link href="http://makeLaugh.github.io/blog/2014/02/14/mknetworkenginede-%5B%3F%5D-ceng-xiao-feng-zhuang/"/>
    <updated>2014-02-14T13:33:09+08:00</updated>
    <id>http://makeLaugh.github.io/blog/2014/02/14/mknetworkenginede-[?]-ceng-xiao-feng-zhuang</id>
    <content type="html"><![CDATA[<p>    之前使用ASI做网络请求的时候，也会对ASI做一层薄薄的封装，以提高代码实际使用时的利用率，后来切换成MKNetworkEngine的时候，也做了一层小封装，现共享如下，<a href="https://github.com/makeLaugh/TWAPP">示例代码</a>在这个目录里：AppGeneral/AppEngine/TWModel/TWNetworkRequest.h里。</p>

<p>    在<strong>TWNetworkRequest.h</strong>头文件里:</p>

<p>    首先声明成功和失败的两个Block：</p>

<pre><code>//成功失败Blocks
typedef void (^TWFinishedBlock) (NSDictionary *data);
typedef void (^TWFailedBlock)   (NSString *error);
</code></pre>

<p>    其次设置网络请求方式，默认为POST</p>

<pre><code>@interface TWNetworkRequest : NSObject
//网络请求方式，默认为POST
@property (copy, nonatomic) NSString *httpMethod;
</code></pre>

<p>    下面是几个具体的网络请求接口</p>

<p>    最基础的一个接口，用得最多的情况</p>

<pre><code>//请求数据接口
- (void)requestDataWithParams:(NSDictionary *)params
                      forPath:(NSString *)path
                     finished:(TWFinishedBlock)finished
                       failed:(TWFailedBlock)failed;
</code></pre>

<p>    可以上传Image的一个接口，相对来说用得没有那么多</p>

<pre><code>- (void)requestDataWithParams:(NSDictionary *)params
                    withImage:(UIImage *)image
                     imageKey:(NSString *)imageKey
                    imageName:(NSString *)imageName
                      forPath:(NSString *)path
                     finished:(TWFinishedBlock)finished
                       failed:(TWFailedBlock)failed;
</code></pre>

<p>    上传和下载文件</p>

<pre><code>//下载文件,hostName为主站点名。
- (void)downloadFileWithFilePath:(NSString *)filePath
                        hostName:(NSString *)hostName
                      toSavePath:(NSString *)savePath
                        finished:(TWFinishedBlock)finished
                          failed:(TWFailedBlock)failed;

//上传文件，path为要上传的接口，fileKey为后台设定的关键字，fileName为自行设定的文件名。
- (void)upLoadFile:(NSData *)fileData
          hostName:(NSString *)hostName
              path:(NSString *)path
           fileKey:(NSString *)fileKey
          fileName:(NSString *)fileName
          finished:(TWFinishedBlock)finished
            failed:(TWFailedBlock)failed;
</code></pre>

<p>    这里的部分是需要注意的，接口参数没什么问题，主要是我定义的几个变量如<code>TWSucceed</code>、<code>code</code>等这些，可能各人的不一样，这些一般是由后台定义的东西，相应的替换掉即可。</p>

<pre><code>- (void)requestDataWithParams:(NSDictionary *)params
                    withImage:(UIImage *)image
                     imageKey:(NSString *)imageKey
                    imageName:(NSString *)imageName
                      forPath:(NSString *)path
                     finished:(TWFinishedBlock)finished
                       failed:(TWFailedBlock)failed
{
    MKNetworkEngine *networkEngine = appDelegate().networkEngine;
    MKNetworkOperation *operation = [networkEngine operationWithPath:path
                                                              params:params
                                                          httpMethod:self.httpMethod];
    if (image)
    {
        NSData *imageData = UIImageJPEGRepresentation(image, 1);
        NSString *mimeType = [NSData contentTypeForImageData:imageData];
        [operation addData:imageData forKey:imageKey mimeType:mimeType fileName:imageName];
    }
    [operation addCompletionHandler:^(MKNetworkOperation *completedOperation)
     {
         NSData *data = [completedOperation.responseString dataUsingEncoding:NSUTF8StringEncoding];
         NSDictionary *resultDict = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];         
         if (completedOperation.HTTPStatusCode == 200)
         {
             if ([resultDict[@"code"] integerValue] == TWSucceed)
             {
                 finished(resultDict);
             }
             else if ([resultDict[@"code"] integerValue] == TWNeedLogin)
             {
                 failed(resultDict[@"msg"]);
                 [mNotificationCenter postNotificationName:kReLoginNotification object:nil];
             }
             else if ([resultDict[@"code"] integerValue] == TWNoData)
             {
                 failed(resultDict[@"msg"]);
             }
             else if ([resultDict[@"code"] integerValue] == TWFailed)
             {
                 failed(resultDict[@"msg"]);
             }
             else
             {
                 failed(resultDict[@"msg"]);
             }
         }
         else
         {
             failed(resultDict[@"msg"]);
         }
     }
                       errorHandler:^(MKNetworkOperation *completedOperation, NSError *error)
     {
         mAlertView(@"网络错误", error.localizedDescription);
     }];
    [networkEngine enqueueOperation:operation];
}
</code></pre>

<p>    具体实现就不贴了，看我给的链接里的示例吧，这只是我针对自己的项目的一点简单封装，以我的要求来实现的，仅作参考吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS项目架构探索]]></title>
    <link href="http://makeLaugh.github.io/blog/2014/01/27/iosxiang-mu-jia-gou-tan-suo/"/>
    <updated>2014-01-27T10:28:48+08:00</updated>
    <id>http://makeLaugh.github.io/blog/2014/01/27/iosxiang-mu-jia-gou-tan-suo</id>
    <content type="html"><![CDATA[<p>    做了iOS项目两年多，对怎么来做好项目架构，做过一些思考，也参考了一些别人的写法，这里写下自己的一些想法与思考，在我的github上面有<a href="https://github.com/makeLaugh/TWAPP">示例代码</a>。</p>

<h4 id="section">首先来看项目在硬盘上的实际目录结构</h4>

<p><img src="http://makeLaugh.github.io/images/blog/2014/iOS项目架构探索/1.png" alt="实体目录结构" /></p>

<p>    在这里，我给每个功能块，都建立实际的目录文件夹来管理，每个功能块里，都建立三个文件夹：Controller、Model、View，这样做，主要是让整个目录结构很清晰，易于管理。	</p>

<h4 id="xcode">再来看看在Xcode中的目录结构</h4>

<p><img src="http://makeLaugh.github.io/images/blog/2014/iOS项目架构探索/2.png" alt="整个项目目录" /></p>

<p>    在Xcode里，整体目录结构和实体文件夹结构保持一致。</p>

<h4 id="lib">项目里的Lib目录</h4>

<p><img src="http://makeLaugh.github.io/images/blog/2014/iOS项目架构探索/3.png" alt="Lib目录" /></p>

<p>    主要用于管理第三方类库，比如我这里添加了FMDB、MKNetworkKit、SDWebImage等几个常用的类库，还有Category里主要是用来管理自己写的一些常用分类; Views管理一些常用的第三方类库。</p>

<h4 id="app">这里是APP真正的结构了，写代码最多的地方</h4>

<p><img src="http://makeLaugh.github.io/images/blog/2014/iOS项目架构探索/4.png" alt="APP代码目录" /></p>

<ul>
  <li>Controller：放各种ViewController，实现逻辑控制，为了缩短类名，我ViewController都缩写为VC</li>
  <li>View：管理ViewController的各个子View</li>
  <li>Model：数据模型文件夹，各种数据模型都放在里面，如果简单的Controller，可能不需要</li>
</ul>

<h4 id="app-1">这里是很多APP都可以通用的一个目录，需要做的修改很少，很多甚至直接拖进去都可以直接使用的</h4>

<p><img src="http://makeLaugh.github.io/images/blog/2014/iOS项目架构探索/5.png" alt="AppGeneral目录" /></p>

<p>AppGeneral分为两个目录：AppDefine和AppEngine</p>

<ul>
  <li>AppDefine：这里管理一些常用的定义
    <ul>
      <li>Appconfig.h：定义了项目里一些常用的常量，比如常用的字体、颜色、常量等等</li>
      <li>MacroDefine.h：定义一通用的一些宏定义，所有项目通用，以m开头</li>
      <li>NetworkAPI.h：定义项目里的网络接口</li>
    </ul>
  </li>
  <li>AppEngine:这里定义了一些通用的数据模型和UI
    <ul>
      <li>TWModel：定义了一些通用的数据模型
        <ul>
          <li>TWModel.h：模型的引入头文件，方便引用</li>
          <li>TWTableDataSource.h：定义TableView的通用DataSource，以减轻使用UITableView的VC复杂度</li>
          <li>TWTableDelegate.h：定义TableView的通用Delegate，以减轻使用UITableView的VC复杂度</li>
          <li>TWTableModel.h：TableView的通用数据模型，对TableView的数据做简单的处理</li>
          <li>TWNetworkRequest.h：对MKNetworkEngine的一层封装，简化网络请求</li>
        </ul>
      </li>
      <li>TWUIKit:定制项目里一些通用的UI样式，这样在具体使用的时候，就不需要再单独进行设置，这里的设置可能每个项目都需要自行根据需求设定
        <ul>
          <li>TWKit.h：UI的引入头文件，方便引用</li>
          <li>TWButton.h：定制Button的样式，如形状，字体大小等等</li>
          <li>TWCell.h：定制Cell的几个通用方法，配合TWTableDataSorce和TWTableDelegate使用</li>
          <li>TWLable：定义Label，如背景为透明，字体大小等</li>
          <li>TWTextField：定制TextField，如圆角，字体大小，背景色等</li>
          <li>TWTextView：同上</li>
          <li>TWViewController.h：定制ViewController，如显示加载页面等</li>
          <li>TWBarButtonItem.h：定制BarButtonItem按钮，如导航栏按钮，在iOS7和之前显示是不一样的，这里把它设置为一样的，使样式统一，体验一致</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="pch">最后来看.pch文件引用</h4>
<p><img src="http://makeLaugh.github.io/images/blog/2014/iOS项目架构探索/6.png" alt="PCH文件" /></p>

<p>    这里我把一些常用的基本上不会改变的、可能会在很多地方都使用到的头文件，一次在这个文件里引用，这样就不会每次使用的时候，都去引入一次了。</p>

<h3 id="section-1">总结一下</h3>
<p>    我觉得，项目架构，最主要的是要使项目结构清晰，易于管理，然后是简化开发。所以我首先把项目文件夹规范起来，定义各个文件夹的作用，这是为了文件管理，使结构清晰。然后，定义一些通用的模板和全局样式，这样就不至于写很多重复的代码，简化开发。</p>

<p>    另外，这里面，其实有一些东西，是可以单独拿出来写一下，比如TWTableDataSource、TWTableDelegate和Views里的一些东西等等，后续再写。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[金陵梦]]></title>
    <link href="http://makeLaugh.github.io/blog/2014/01/26/jin-ling-meng/"/>
    <updated>2014-01-26T17:36:11+08:00</updated>
    <id>http://makeLaugh.github.io/blog/2014/01/26/jin-ling-meng</id>
    <content type="html"><![CDATA[<h3 id="section">           <strong>随感-金陵梦</strong></h3>

<p>金陵城里金陵梦，石头城外伴石眠。</p>

<p>秣陵秋至池荷尽，良辰好景是他年。</p>

<p><em>2013-09-24 13:57</em></p>

<p><img src="http://makeLaugh.github.io/images/blog/2014/金陵梦.jpg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSString属性声明中的copy和retain区别]]></title>
    <link href="http://makeLaugh.github.io/blog/2014/01/26/nsstringshu-xing-sheng-ming-zhong-de-copyhe-retainqu-bie/"/>
    <updated>2014-01-26T14:39:00+08:00</updated>
    <id>http://makeLaugh.github.io/blog/2014/01/26/nsstringshu-xing-sheng-ming-zhong-de-copyhe-retainqu-bie</id>
    <content type="html"><![CDATA[<p>    关于NSString在属性声明中的copy和retain，我想存在一些误解，即和其它不一样的地方。</p>

<p><strong>首先做以下几个变量声明：</strong>   </p>

<pre><code>@property (retain, nonatomic) NSString *retainStr;
@property (copy, nonatomic)   NSString *copyStr;
@property (retain, nonatomic) NSMutableString *retainMStr;
@property (copy, nonatomic)   NSMutableString *copyMStr;
</code></pre>

<p><strong>实现代码如下：</strong></p>

<pre><code>NSMutableString *mStr = [NSMutableString string];
[mStr setString:@"我没变"];
self.retainStr   = mStr;
self.copyStr     = mStr;
self.retainMStr = mStr;
self.copyMStr   = mStr;

NSLog(@"retainStr:%@",  self.retainStr);
NSLog(@"copyStr:%@",    self.copyStr);
NSLog(@"retainMStr:%@", self.retainMStr);
NSLog(@"copyMStr:%@",   self.copyMStr);
NSLog(@"\n");

[mStr setString:@"我变了"];
NSLog(@"retainStr:%@",  self.retainStr);
NSLog(@"copyStr:%@",    self.copyStr);
NSLog(@"retainMStr:%@", self.retainMStr);
NSLog(@"copyMStr:%@",   self.copyMStr);
NSLog(@"\n");

NSString *str = @"我来了";//[[NSString alloc] initWithFormat:@"我来了"];//两种方式都一样。
self.retainStr  = str;
self.copyStr    = str;
self.retainMStr = [str mutableCopy];
self.copyMStr   = [str mutableCopy];
NSLog(@"retainStr:%@",  self.retainStr);
NSLog(@"copyStr:%@",    self.copyStr);
NSLog(@"retainMStr:%@", self.retainMStr);
NSLog(@"copyMStr:%@",   self.copyMStr);
NSLog(@"\n");

str =@"我走了";//[[NSStringalloc] initWithFormat:@"我走了"];//两种方式都一样
NSLog(@"retainStr:%@",  self.retainStr);
NSLog(@"copyStr:%@",    self.copyStr);
NSLog(@"retainMStr:%@", self.retainMStr);
NSLog(@"copyMStr:%@",   self.copyMStr);
NSLog(@"\n");
</code></pre>

<p><strong>打印结果如下：</strong></p>

<pre><code>2012-10-12 13:53:14.858 StringDemo[1515:11303] retainStr:我没变
2012-10-12 13:53:14.860 StringDemo[1515:11303] copyStr:我没变
2012-10-12 13:53:14.861 StringDemo[1515:11303] retainMStr:我没变
2012-10-12 13:53:14.862 StringDemo[1515:11303] copyMStr:我没变
2012-10-12 13:53:14.863 StringDemo[1515:11303] 
2012-10-12 13:53:14.864 StringDemo[1515:11303] retainStr:我变了
2012-10-12 13:53:14.865 StringDemo[1515:11303] copyStr:我没变
2012-10-12 13:53:14.866 StringDemo[1515:11303] retainMStr:我变了
2012-10-12 13:53:14.867 StringDemo[1515:11303] copyMStr:我没变
2012-10-12 13:53:14.868 StringDemo[1515:11303] 
2012-10-12 13:53:14.869 StringDemo[1515:11303] retainStr:我来了
2012-10-12 13:53:14.869 StringDemo[1515:11303] copyStr:我来了
2012-10-12 13:53:14.870 StringDemo[1515:11303] retainMStr:我来了
2012-10-12 13:53:14.871 StringDemo[1515:11303] copyMStr:我来了
2012-10-12 13:53:14.872 StringDemo[1515:11303] 
2012-10-12 13:53:14.873 StringDemo[1515:11303] retainStr:我来了
2012-10-12 13:53:14.874 StringDemo[1515:11303] copyStr:我来了
2012-10-12 13:53:14.875 StringDemo[1515:11303] retainMStr:我来了
2012-10-12 13:53:14.876 StringDemo[1515:11303] copyMStr:我来了
</code></pre>

<p><strong>由此可以看出：</strong></p>

<ul>
  <li>对源头是NSMutableString的字符串，retain仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种retain方式声明的变量（无论被赋值的变量是可变的还是不可变的），它也会跟着改变; 而copy声明的变量，它不会跟着源头改变，它实际上是深拷贝。</li>
  <li>对源头是NSString的字符串，无论是retain声明的变量还是copy声明的变量，当第二次源头的字符串重新指向其它的地方的时候，它还是指向原来的最初的那个位置，也就是说其实二者都是指针引用，也就是浅拷贝。</li>
</ul>

<p>   另外说明一下，这两者对内存计数的影响都是一样的，都会增加内存引用计数，都需要在最后的时候做处理。</p>

<p>   其实说白了，对字符串为啥要用这两种方式？我觉得还是一个安全问题，比如声明的一个NSString *str变量，然后把一个NSMutableString *mStr变量的赋值给它了，如果要求str跟着mStr变化，那么就用retain;如果str不能跟着mStr一起变化，那就用copy。而对于要把NSString类型的字符串赋值给str，那两都没啥区别。不会影响安全性，内存管理也一样。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSString的内存管理]]></title>
    <link href="http://makeLaugh.github.io/blog/2014/01/26/nsstringde-nei-cun-guan-li/"/>
    <updated>2014-01-26T14:03:07+08:00</updated>
    <id>http://makeLaugh.github.io/blog/2014/01/26/nsstringde-nei-cun-guan-li</id>
    <content type="html"><![CDATA[<p>    本文参考了这篇文章，主要针对<a href="http://www.cnblogs.com/hellocby/archive/2012/08/23/2652201.html">这篇文章</a>做了一些补充说明，详细说明NSString的内存管理差异。</p>

<p><strong>生成NSString的方式:</strong></p>

<p>方法1.直接赋值:   </p>

<pre><code>NSString *testStr1 = @"a";
</code></pre>

<p>方法2.类函数初始化生成:     </p>

<pre><code>NSString *testStr2 = [NSString stringWithString:@"b"];
NSString *testStr3 = [NSString stringWithFormat:@"c"];
</code></pre>

<p>方法3.实例方法初始化生成:　</p>

<pre><code>NSString *testStr4 = [[NSString alloc] initWithString:@"d"];
NSString *testStr5 = [[NSString alloc] initWithFormat:@"e"];
</code></pre>

<p>首先查看它们的地址和引用计数：</p>

<pre><code>2012-10-11 17:35:25.601 StringDemo[8514:11303] test1Address:0x4698
2012-10-11 17:35:25.601 StringDemo[8514:11303] test2Address:0x46a8
2012-10-11 17:35:25.602 StringDemo[8514:11303] test3Address:0x746c820
2012-10-11 17:35:25.602 StringDemo[8514:11303] test4Address:0x46c8
2012-10-11 17:35:25.603 StringDemo[8514:11303] test5Address:0x7455990
2012-10-11 17:35:25.585 StringDemo[8514:11303] test1:4294967295
2012-10-11 17:35:25.586 StringDemo[8514:11303] test2:4294967295
2012-10-11 17:35:25.596 StringDemo[8514:11303] test3:1
2012-10-11 17:35:25.600 StringDemo[8514:11303] test4:4294967295
2012-10-11 17:35:25.600 StringDemo[8514:11303] test5:1
</code></pre>

<p>  从上可以看出，<code>test1,test2,test4</code>都是在一个内存区域，也就是上文所说的常量内存区。test3,test5在一个内存区，也就是堆区。</p>

<p>  这里就有一个疑问：<code>[NSString alloc] initWithString:@"d"</code>这种方式初始化的字符串，也就是test4.应该是位于堆区的，但为什么会跑到常量内存区来呢？据说是因为xcode对这种方式做了处理，还包括<code>[NSString stringWithString:@"b"]</code>这种方式，这两种初始化字符串都等同于@”ddd”了。所以说test2,test4都同等于test1了。</p>

<p>  还有，对于<code>NSString *testStr3 = [NSString stringWithFormat:@"c"]</code>;这种初始化的字符串，只要一写release语句就会挂掉，但其它的都不会挂掉，test1,test2,test4好理解，因为release本来就不会起作用;但testStr5无论release多少次也不会挂掉，只会在控制台报警告：malloc: <strong>* error for object 0x744d650: double free</strong>* set a breakpoint in malloc_error_break to debug。这个猜测应该是也xcode做了优化吧。</p>

<p>  对现在4.4之后的编译器，<code>NSString *testStr2 = [NSString stringWithString:@"b"];</code>这种写法会报警告了：Using ‘stringWithString’ with a literal is redundant。也就是说这种写法是多余的了，它给的建议是用＝@”b”这种方式来代替了。</p>

<p><strong>小结下吧：</strong></p>

<p>  对NSString的初始化方法，<code>对于test1,test2,test4这三种的话建议用＝@“字符串”来使用</code>，因为本来就是一样的。test3,test5这两种的话，建议用texst3这种，方便点，不用管内存问题，系统自已管理。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新年计划]]></title>
    <link href="http://makeLaugh.github.io/blog/2014/01/11/xin-nian-ji-hua/"/>
    <updated>2014-01-11T23:08:13+08:00</updated>
    <id>http://makeLaugh.github.io/blog/2014/01/11/xin-nian-ji-hua</id>
    <content type="html"><![CDATA[<p>    2014，我的任务，我的成长！</p>

<ol>
  <li>搭建一个自己的博客，保持每两周更新至少一篇博文</li>
  <li>熟练掌握PHP语言和后台开发技术</li>
  <li>熟练掌握Javascript语言和前端开发技术</li>
  <li>熟练掌握MySql技术;</li>
  <li>深入学习iOS开发技术，阅读一本关于iOS高级开发的书籍</li>
  <li>全面学习iOS7新技术（6月前完成）</li>
  <li>初步学习一门新的语言：Go语言/D语言</li>
  <li>温习C语言(C语言的重要性超出了之前的预料)</li>
  <li>读万卷书，不如行万里路：至少远游三次（出南京）。</li>
  <li>以史为鉴：阅读《易中天大中华史》，全面了解中国历史; 了解欧洲发展史</li>
  <li>锻炼身体，每周最少打一次篮球(不下雨)。</li>
</ol>

<p>    新年计划的制定，基于几个考虑：<br />
    首先，写博客是一个积累知识和锻炼自己写作能力的过程;<br />
    其次，后台和前端技术，也许不会去找这方面的工作，但是，现在所有的项目，基本上都逃离不了这些知识，学习这些知识可以扩充自己的视野和知识面，学习C语言和新语言也一样，学C语言更多的是深入学习编程技术，本身OC也是基于C的扩展。  <br />
    再次，学历史，知过去，看未来。<br />
    最后，身体是革命的本钱; 远游放松心情，锻炼强健体魄。
    
    
    </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你好，github]]></title>
    <link href="http://makeLaugh.github.io/blog/2014/01/10/ni-hao-%2Cgithub/"/>
    <updated>2014-01-10T22:04:54+08:00</updated>
    <id>http://makeLaugh.github.io/blog/2014/01/10/ni-hao-,github</id>
    <content type="html"><![CDATA[<p>    我的第一个博客，欢迎大家光临！</p>

<p>    从这里，算是正式开启我的博客之路了，之前在博客园写过一些博客，写得断断续续的，这次终于正式的搭建了一个自己的博客，以后尽力保持有新的感触、新的成长，就会做一些记录，记录生活成长的点滴！</p>

<p>    我只想说，您好，github，博客，2014，我来了！</p>
]]></content>
  </entry>
  
</feed>
