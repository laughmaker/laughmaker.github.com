
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>闻竹</title>
  <meta name="author" content="makeLaugh">

  
  <meta name="description" content="PHP对MongoDB的扩展文档地址：http://us3.php.net/manual/en/book.mongo.php 在PHP的Mongo扩展中，有4类接口对象： 1.针对MongoDB的连接的操作：MongoClient
http://us3.php.net/manual/en/ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://makeLaugh.github.io/blog">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="闻竹" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'> -->
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">闻竹</a></h1>
  
    <h2>于车马喧哗中守一份宁静      于万马齐喑中持一片热忱</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:makeLaugh.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">主页</a></li>
  <li><a href="/blog/archives">文章归档</a></li>
  <li><a href="/about">关于我</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/04/mongodbchang-yong-cao-zuo/">Mongodb常用操作</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-04T15:56:30+08:00" pubdate data-updated="true">Jan 4<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<p>PHP对MongoDB的扩展文档地址：http://us3.php.net/manual/en/book.mongo.php</p>

<pre><code>在PHP的Mongo扩展中，有4类接口对象：  
1.针对MongoDB的连接的操作：MongoClient
http://us3.php.net/manual/en/class.mongoclient.php
2.针对MongoDB中数据库的操作：MongoDB
http://us3.php.net/manual/en/book.mongo.php
3.针对MongoDB中的Collection的操作：MongoCollection
http://us3.php.net/manual/en/class.mongocollection.php
4.针对查询结果集的操作：MongoCursor和MongoCommandCursor
http://us3.php.net/manual/en/class.mongocursor.php
http://us3.php.net/manual/en/class.mongocommandcursor.php
</code></pre>

<hr />

<h4 id="section">常用管理命令</h4>
<pre><code>./mongo	#启动Mongo Shell
use foo	#进入数据库foo
db.createUser({user:'hzdRW', pwd:'hezhendong', roles:[{role:'dbOwner', db:'hzdDB'}]} #添加用户或修改用户密码
db.system.users.find()	#查看用户列表
db.auth('name', 'pwd')	#用户认证
db.removeUser('name')	#删除用户
show users	#查看所有用户
show dbs	#查看所有数据库
show collectios  #查看所有的collection
db.printCollectionStats()	#查看各collection的状态
db.printReplicationInfo()	#查看主从复制状态
db.repariDatabase()	 #修复数据库
db.copyDatabase(fromDB, toDB, fromHost[, username, password])  #拷贝数据库
db.collection_name.drop()  #删除集合
db.dropDatabase()  #删除当前数据库
db.shutdownServer() #关闭当前服务程序
exit #退出当前shel
</code></pre>

<hr />

<h4 id="section-1">数据库连接</h4>
<p>1.默认连接本机的27017端口 </p>

<pre><code>$mongo = new MongoClient();
</code></pre>

<p>2.自定义格式连接，一般ip为本机可写为localhost,port可省略  </p>

<pre><code>格式：$mongo = new MongoClient('mongodb://username:password@ip:port');  
</code></pre>

<hr />

<h4 id="section-2">查询</h4>
<p>1.find findOne findAndModify</p>

<ul>
  <li>
    <p>查询user集合中全部内容：</p>

    <pre><code>  db.user.find();
</code></pre>
  </li>
  <li>
    <p>查询user集合中age的值为27的文档：</p>

    <pre><code>  db.user.find({"age":27});
</code></pre>
  </li>
  <li>
    <p>查询user集合中age为27,username为joe的内容：</p>

    <pre><code>  db.user.find({"age":27, "username":27});
</code></pre>
  </li>
  <li>
    <p>查询user集合中的所有内容，但只返回username和email键的值：</p>

    <pre><code>  db.user.find({}, {"username":1, "email":1});
</code></pre>
  </li>
  <li>
    <p>查询user集合中的所有内容，但剔除age键：</p>

    <pre><code>  db.user.find({}, {"age": 0});
</code></pre>
  </li>
  <li>
    <p>查询user集合中的age为18的第一条记录：</p>

    <pre><code>  db.user.findOne({"age":18});
</code></pre>
  </li>
  <li>
    <p>根据查询条件找到相应的记录并对一条结果做更新操作，其中query为查询条件，sort指定排序，remove表示删除（remove和update不能同时指定），new表示返回更新之前还是之后的结果，这条命令只能返回一条结果</p>

    <pre><code>  db.user.findAndModify({"query":{"username":"joe"}, "sort":{"age":1}, "remove":true, "new":true});
</code></pre>
  </li>
</ul>

<p>2.查询操作符</p>

<pre><code>$lt(&lt;) $lte(&lt;=) $gt(&gt;=) $gte(&gt;=) 
$in(匹配一个键的多个值) $nin(与列出来的所有值都不匹配)
$all:匹配数组中所有元素，模糊匹配，不关注顺序
$not:反向匹配
$size:匹配数组长度
</code></pre>

<ul>
  <li>
    <p>查询age在18～30(含)岁之间的用户：</p>

    <pre><code>  db.user.find({"age":{"$gte":18, "$lte":30}});
</code></pre>
  </li>
  <li>
    <p>查询age为18、20、22岁的用户：</p>

    <pre><code>  db.user.find({"age":{"$in":[18, 20, 22]}});
</code></pre>
  </li>
  <li>
    <p>查询age不为18、20、22岁的所有用户：</p>

    <pre><code>  db.user.find({"age":{"$nin":[18, 20, 22]}});
</code></pre>
  </li>
  <li>
    <p>查询username不为joe的所有用户：</p>

    <pre><code>  db.user.find({"username":{"$not":"joe"}});
</code></pre>
  </li>
</ul>

<p>3.$exists<br />
判断字段是否存在</p>

<ul>
  <li>
    <p>查询所有存在username字段的记录：</p>

    <pre><code>  db.user.find({"username":{"$exsits":true}});
</code></pre>
  </li>
  <li>
    <p>查询所有不存在username字段的记录：</p>

    <pre><code>  db.user.find({"username":{"$exsits":false}});
</code></pre>
  </li>
</ul>

<p>4.$slice<br />
返回数组的一个子集合</p>

<ul>
  <li>
    <p>查询user集合中username为joe的前10个用户：</p>

    <pre><code>  db.user.find({"username":"joe"}, {"$slice": 10});
</code></pre>
  </li>
  <li>
    <p>查询user集合中从第21条记录开始的10条记录：</p>

    <pre><code>  db.user.find({"username":"joe"}, {"$slice":[20, 10]});
</code></pre>
  </li>
</ul>

<p>5.对结果排序  </p>

<ul>
  <li>对年龄升序：db.user.find().sort({“age”:1});</li>
  <li>对年龄降序：db.user.find().sort({“age”:-1});</li>
</ul>

<p>6.限制返回数据条数  </p>

<ul>
  <li>返回5条记录:db.user.find().limit(5)</li>
  <li>从第3条记录开始，返回5条记录:db.user.find().skip(3).limit(5)</li>
  <li>返回记录条数:db.user.find().count()</li>
  <li>返回限制条件后的记录数量:db.user.find().skip(10).limit(5).count(1)</li>
</ul>

<hr />

<h4 id="section-3">插入、更新、删除</h4>
<p><code>insert save update remove</code><br />
若存在_id主键，insert()不做操作，且提示错误，save()改变原来的内容为新内容。</p>

<p><strong>修改器</strong>:</p>

<pre><code>$set:修改字段
$unset:删除字段，不论对目标键使用1、0、-1或者具体的字符串等都是可以删除该目标键。
$rename:修改字段字
$push、pushAll:向数组末尾追加数据，字段不存在则创建
$addToSet:向数组类型乐加数据时避免重复
$each:遍历数组
$pop:从数组中删除数据，{"$pop":{key:1}}从末尾删除，-1从头部删除
$pull和$pullAll:从数组中删除指定数据
</code></pre>

<ul>
  <li>
    <p>向user集合中插入单个文档：</p>

    <pre><code>  db.user.insert({"username":"joe", "age":18});
</code></pre>
  </li>
  <li>
    <p>清空user集合：</p>

    <pre><code>  db.user.remove();
</code></pre>
  </li>
  <li>
    <p>清除user集合中所有age为18的数据：</p>

    <pre><code>  db.user.remove({"age":18});
</code></pre>
  </li>
  <li>
    <p>根据query条件修改，如果不存在则插入，物许修改多条记录：</p>

    <pre><code>  db.foo.update({"y":1}, {"$set":{"x":2}}, upsert=true, multi=true);
</code></pre>
  </li>
  <li>
    <p>找到username为joe的记录，并删除email字段：</p>

    <pre><code>  db.user.update({"username":"joe"}, {"$unset":{"email":1}});
</code></pre>
  </li>
  <li>
    <p>修改username为nickname:</p>

    <pre><code>  db.user.update({}, {"$rename":{"username":"nickname"}});
</code></pre>
  </li>
</ul>

<hr />

<h4 id="section-4">修改器详解示例</h4>

<pre><code>对于文档的更新除替换外，针对某个或多个文档只需要部分更新可使用原子的更新修改器，能够高效的进行文档更新。更新修改器是中特殊的键， 用来指定复杂的操作，比如增加、删除或者调整键，还可能是操作数组或者内嵌文档。
</code></pre>

<p>1.$inc</p>

<p>$inc可以对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作。</p>

<pre><code>示例文档：{"uid":"201203","type":"1",size:10}
&gt; db.b.insert({"uid":"201203","type":"1",size:10})
&gt; db.b.find()
{ "_id" : ObjectId("5003b6135af21ff428dafbe6"), "uid" : "201203", "type" : "1",
"size" : 10 }
&gt; db.b.update({"uid" : "201203"},{"$inc":{"size" : 1}})
&gt; db.b.find()
{ "_id" : ObjectId("5003b6135af21ff428dafbe6"), "uid" : "201203", "type" : "1",
"size" : 11 }
&gt; db.b.update({"uid" : "201203"},{"$inc":{"size" : 2}})
&gt; db.b.find()
{ "_id" : ObjectId("5003b6135af21ff428dafbe6"), "uid" : "201203", "type" : "1",
"size" : 13 }
&gt; db.b.update({"uid" : "201203"},{"$inc":{"size" : -1}})
&gt; db.b.find()
{ "_id" : ObjectId("5003b6135af21ff428dafbe6"), "uid" : "201203", "type" : "1",
"size" : 12 }
</code></pre>

<p>2.$set</p>

<p>用来指定一个键并更新键值，若键不存在并创建，对于内嵌文档在使用$set更新时，使用”.”连接的方式。</p>

<pre><code>&gt; db.a.findOne({"uid" : "20120002","type" : "3"})
{ "_id" : ObjectId("500216de81b954b6161a7d8f"), "desc" : "hello world2!", "num"
: 40, "sname" : "jk", "type" : "3", "uid" : "20120002" }
</code></pre>

<p>–size键不存在的场合</p>

<pre><code>&gt; db.a.update({"uid" : "20120002","type" : "3"},{"$set":{"size":10}})
&gt; db.a.findOne({"uid" : "20120002","type" : "3"})
{ "_id" : ObjectId("500216de81b954b6161a7d8f"), "desc" : "hello world2!", "num"
: 40, "size" : 10, "sname" : "jk", "type" : "3", "uid" : "20120002" }
</code></pre>

<p>–sname键存在的场合</p>

<pre><code>&gt; db.a.update({"uid" : "20120002","type" : "3"},{"$set":{"sname":"ssk"}})
&gt; db.a.find()
{ "_id" : ObjectId("500216de81b954b6161a7d8f"), "desc" : "hello world2!", "num"
: 40, "size" : 10, "sname" : "ssk", "type" : "3", "uid" : "20120002" }
{ "_id" : ObjectId("50026affdeb4fa8d154f8572"), "desc" : "hello world1!", "num"
: 50, "sname" : "jk", "type" : "1", "uid" : "20120002" }
</code></pre>

<p>–可改变键的值类型</p>

<pre><code>&gt; db.a.update({"uid" : "20120002","type" : "3"},{"$set":{"sname":["java",".net","c++"]}})
&gt; db.a.findOne({"uid" : "20120002","type" : "3"})
{
        "_id" : ObjectId("500216de81b954b6161a7d8f"),
        "desc" : "hello world2!",
        "num" : 40,
        "size" : 10,
        "sname" : [
                "java",
                ".net",
                "c++"
        ],
        "type" : "3",
        "uid" : "20120002"
}
</code></pre>

<p>对于内嵌的文档，$set又是如何进行更新的内嵌的文档的呢，请看下面的示例：</p>

<pre><code>示例文档：{"name":"toyota","type":"suv","size":{"height":10,"width":5,"length":15}}
&gt; db.c.findOne({"name":"toyota"})
{
        "_id" : ObjectId("5003be465af21ff428dafbe7"),
        "name" : "toyota",
        "type" : "suv",
        "size" : {
                "height" : 10,
                "width" : 5,
                "length" : 15
        }
}
&gt; db.c.update({"name":"toyota"},{"$set":{"size.height":8}})
&gt; db.c.findOne({"name":"toyota"})
{
        "_id" : ObjectId("5003be465af21ff428dafbe7"),
        "name" : "toyota",
        "type" : "suv",
        "size" : {
                "height" : 8,
                "width" : 5,
                "length" : 15
        }
}
&gt; db.c.update({"name":"toyota"},{"$set":{"size.width":7}})
&gt; db.c.findOne({"name":"toyota"})
{
        "_id" : ObjectId("5003be465af21ff428dafbe7"),
        "name" : "toyota",
        "type" : "suv",
        "size" : {
                "height" : 8,
                "width" : 7,
                "length" : 15
        }
}
</code></pre>

<p>3.$unset</p>

<p>从字面就可以看出其意义，主要是用来删除键。
使用修改器$unset时，不论对目标键使用1、0、-1或者具体的字符串等都是可以删除该目标键。</p>

<pre><code>示例操作效果如下：
&gt; db.a.update({"uid" : "20120002","type" : "3"},{"$unset":{"sname":1}})
&gt; db.a.findOne({"uid" : "20120002","type" : "3"})
{
        "_id" : ObjectId("500216de81b954b6161a7d8f"),
        "desc" : "hello world2!",
        "num" : 40,
        "size" : 10,
        "type" : "3",
        "uid" : "20120002"
}
&gt; db.a.update({"uid" : "20120002","type" : "3"},{"$unset":{"num":0}})
&gt; db.a.findOne({"uid" : "20120002","type" : "3"})
{
        "_id" : ObjectId("500216de81b954b6161a7d8f"),
        "desc" : "hello world2!",
        "size" : 10,
        "type" : "3",
        "uid" : "20120002"
}
&gt; db.a.update({"uid" : "20120002","type" : "3"},{"$unset":{"size":-1}})
&gt; db.a.findOne({"uid" : "20120002","type" : "3"})
{
        "_id" : ObjectId("500216de81b954b6161a7d8f"),
        "desc" : "hello world2!",
        "type" : "3",
        "uid" : "20120002"
}
&gt; db.a.update({"uid" : "20120002","type" : "3"},{"$unset":{"desc":"sssssss"}})
&gt; db.a.findOne({"uid" : "20120002","type" : "3"})
{
        "_id" : ObjectId("500216de81b954b6161a7d8f"),
        "type" : "3",
        "uid" : "20120002"
}
</code></pre>

<p>4.数组修改器–$push</p>

<p>$push–向文档的某个数组类型的键添加一个数组元素，不过滤重复的数据。添加时键存在，要求键值类型必须是数组；键不存在，则创建数组类型的键。</p>

<p>示例操作效果如下：</p>

<pre><code>&gt; db.c.find()
{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "type" : "suv",
"size" : { "height" : 8, "width" : 7, "length" : 15 } }
</code></pre>

<p>先push一个当前文档中不存在的键title</p>

<pre><code>&gt; db.c.update({"name" : "toyota"},{$push:{"title":"t1"}})
&gt; db.c.find()
{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,
 "width" : 7, "length" : 15 }, "title" : [ "t1" ], "type" : "suv" }
</code></pre>

<p>再向title中push一个值</p>

<pre><code>&gt; db.c.update({"name" : "toyota"},{$push:{"title":"t2"}})
&gt; db.c.find()
{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,
 "width" : 7, "length" : 15 }, "title" : [ "t1", "t2" ], "type" : "suv" }
</code></pre>

<p>再向title中push一个值</p>

<pre><code>&gt; db.c.update({"name" : "toyota"},{$push:{"title":"t2"}})
&gt; db.c.find()
{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,
 "width" : 7, "length" : 15 }, "title" : [ "t1", "t2", "t2" ], "type" : "suv" }
</code></pre>

<p>再向一个已经存在的键值非数组类型的键push一个值</p>

<pre><code>&gt; db.c.update({"name" : "toyota"},{$push:{"size.height":10}})
Cannot apply $push/$pushAll modifier to non-array
&gt; db.c.update({"name" : "toyota"},{$push:{"name":"ddddddd"}})
Cannot apply $push/$pushAll modifier to non-array
</code></pre>

<p>5.数组修改器–$ne/$addToSet</p>

<p>主要给数组类型键值添加一个元素时，避免在数组中产生重复数据，$ne在有些情况是不通行的。</p>

<pre><code>&gt; db.c.update({"title" : {$ne:"t2"}},{$push:{"title":"t2"}})
&gt; db.c.find()
{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,
 "width" : 7, "length" : 15 }, "title" : [ "t1", "t2", "t2" ], "type" : "suv" }
&gt; db.c.update({"name" : "toyota"},{$addToSet:{"title":"t2"}})
&gt; db.c.find()
{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,
 "width" : 7, "length" : 15 }, "title" : [ "t1", "t2", "t2" ], "type" : "suv" }
</code></pre>

<p>6.数组修改器–$pop、$pull</p>

<p>$pop从数组的头或者尾删除数组中的元素，</p>

<p>示例如下：</p>

<pre><code>{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,  "width" : 7, "length" : 15 }, "title" : [ "t1", "t2", "t3", "t4" ],"type" : "suv" }
</code></pre>

<p>从数组的尾部删除 1</p>

<pre><code>&gt; db.c.update({"name" : "toyota"},{$pop:{"title":1}})
&gt; db.c.find()
{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,
 "width" : 7, "length" : 15 }, "title" : [ "t1", "t2", "t3" ], "type" : "suv" }
</code></pre>

<p>从数组的头部 -1</p>

<pre><code>&gt; db.c.update({"name" : "toyota"},{$pop:{"title":-1}})
&gt; db.c.find()
{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,
 "width" : 7, "length" : 15 }, "title" : [ "t2", "t3" ], "type" : "suv" }
</code></pre>

<p>从数组的尾部删除 0</p>

<pre><code>&gt; db.c.update({"name" : "toyota"},{$pop:{"title":0}})
&gt; db.c.find()
{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,
 "width" : 7, "length" : 15 }, "title" : [ "t2" ], "type" : "suv" }
</code></pre>

<p>$pull从数组中删除满足条件的元素，示例如下：</p>

<pre><code>{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,
 "width" : 7, "length" : 15 }, "title" : [ "t1", "t2", "t2", "t3" ],"type" : "suv" }
 
&gt; db.c.update({"name" : "toyota"},{$pull:{"title":"t2"}})
&gt; db.c.find()
{ "_id" : ObjectId("5003be465af21ff428dafbe7"), "name" : "toyota", "size" : { "height" : 8,
 "width" : 7, "length" : 15 }, "title" : [ "t1", "t3" ], "type" : "suv" }
</code></pre>

<p>7.数组的定位修改器</p>

<p>在需要对数组中的值进行操作的时候，可通过位置或者定位操作符（”$”)，数组是0开始的，可以直接将下标作为键来选择元素。<br />
使用$定位操作符时，若为多个文档满足条件，则只更新第一个文档。</p>

<p>示例如下：</p>

<pre><code>{"uid":"001",comments:[{"name":"t1","size":10},{"name":"t2","size":12}]}
&gt; db.c.find({"uid":"001"})
{ "_id" : ObjectId("5003da405af21ff428dafbe8"), "uid" : "001", "comments" : [ {
"name" : "t1", "size" : 10 }, { "name" : "t2", "size" : 12 } ] }
&gt; db.c.update({"uid":"001"},{$inc:{"comments.0.size":1}})
&gt; db.c.find({"uid":"001"})
{ "_id" : ObjectId("5003da405af21ff428dafbe8"), "uid" : "001", "comments" : [ {
"name" : "t1", "size" : 11 }, { "name" : "t2", "size" : 12 } ] }
&gt; db.c.update({"comments.name":"t1"},{$set:{"comments.$.size":1}})
&gt; db.c.find({"uid":"001"})
{ "_id" : ObjectId("5003da405af21ff428dafbe8"), "uid" : "001", "comments" : [ {
"name" : "t1", "size" : 1 }, { "name" : "t2", "size" : 12 } ] }
</code></pre>

<p>8.upsert</p>

<p>upsert是一种特殊的更新。当没有符合条件的文档，就以这个条件和更新文档为基础创建一个新的文档，如果找到匹配的文档就正常的更新。
使用upsert，既可以避免竞态问题，也可以减少代码量（update的第三个参数就表示这个upsert，参数为true时）</p>

<pre><code>&gt; db.c.remove()
&gt; db.c.update({"size":11},{$inc:{"size":3}})
&gt; db.c.find()
&gt; db.c.update({"size":11},{$inc:{"size":3}},false)
&gt; db.c.find()
&gt; db.c.update({"size":11},{$inc:{"size":3}},true)
&gt; db.c.find()
{ "_id" : ObjectId("5003ded6c28f67507a6df1de"), "size" : 14 }
</code></pre>

<p>9.save函数</p>

<p>1.可以在文档不存在的时候插入，存在的时候更新，只有一个参数文档。<br />
2.要是文档含有”_id”，会调用upsert。否则，会调用插入。</p>

<pre><code>&gt; db.a.find()
{ "_id" : ObjectId("50026affdeb4fa8d154f8572"), "desc" : "hello world1!", "num": 50,
 "sname" : "jk", "type" : "1", "uid" : "20120002" }
&gt; var o = db.a.findOne()
&gt; o.num = 55
55
&gt; db.a.save(o)
&gt; db.a.find()
{ "_id" : ObjectId("50026affdeb4fa8d154f8572"), "desc" : "hello world1!", "num": 55,
 "sname" : "jk", "type" : "1", "uid" : "20120002" }
</code></pre>

<hr />

<h4 id="section-5">索引管理</h4>

<ul>
  <li>
    <p>在字段firstname升序和lastname降序上创建一个名为idx_name的联合索引</p>

    <pre><code>  db.user.ensureIndex({"firstname":1, "lastname":-1}, {"name":"idx_name"})
</code></pre>
  </li>
  <li>
    <p>在username上创建一个唯一索引</p>

    <pre><code>  db.user.ensureIndex({"username":1}, {"unique":true});
</code></pre>
  </li>
</ul>

</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/04/phpkai-fa-gui-fan/">Phpkai Fa Gui Fan</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-04T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4 id="php">PHP命名规范</h4>

<ol>
  <li>类文件都是以“<strong>.class.php</strong>“为后缀，且类文件名只允许字母，使用驼峰法命名，并且首字母大写，例如：DbMysql.class.php 。</li>
  <li>配置和函数等其他类库文件之外的文件一般是分别以“.inc.php“和”.php“为后缀，且文件名命名使用小写字母和下划线的方式，多个单词之间以下 划线分隔，例如config.inc.php ， common.php，install_function.php 。</li>
  <li>确保文件的命名和调用大小写一致，是由于在类Unix系统上面，对大小写是敏感的。</li>
  <li>类名和文件名一致（包括上面说的大小写一致），且类名只允许字母，例如 UserAction类的文件命名是UserAction.class.php， InfoModel类的文件名是InfoModel.class.php 。</li>
  <li>控制器类以Action为后缀，例如 UserAction、InfoAction ，模型类以Model为后缀，例如UserModel、InfoModel ，其他类也分别以相应分类为后缀，例如Service 、Widget。</li>
  <li>方法名只允许由字母组成，下划线是不允许的，首字母要小写，其后每个单词首字母要大写，即所谓的 “驼峰法命名” 规则，且越详细越好，应该能够描述清楚该方法的功能，例如switchModel、findPage。</li>
  <li>属性的命名只允许由字母组成，下划线是不允许的，首字母要小写，其后每个单词首字母要大写，即所谓的 “驼峰法命名” 规则，例如tablePrefix、tableName 。</li>
  <li>
    <p>对于对象成员的访问，我们必须始终使用 “get” 和 “set” 方法。例如：  </p>

    <pre><code> class Foo
 {
     protected $_testObj;
     public function getTestObj()
	
     {
         return $this-&gt;_testObj;
     }
     public function setTestObj($testObj)
     {
         $this-&gt;testObj = $_testObj;
     }
 }
</code></pre>
  </li>
  <li>
    <p>当类成员方法被声明为 private 时，必须分别以双下划线 “<em>_“为开头；被声明为 protected 时，必须分别以单下划线 “</em>” 为开头；一般情况下的方法不含下划线。例如 ：</p>

    <pre><code> class Foo
 {
     private function __example()
     {
         // ...
     }
     protected function _example()
     {
         // ...
     }
     public function example()
     {
         // ...
     }
 }
</code></pre>
  </li>
  <li>
    <p>如果我们需要把一些经常使用的方法定义为全局函数，那么应该把它们以静态 (static) 的形式定义在类中。例如：</p>

    <pre><code>class Think
{
    // ...
    static public function autoload($classname)
    {
        // ...
    }
}
</code></pre>
  </li>
  <li>被声明为 private的类成员属性必须由双下划线 “<em>_” 作为开头；被声明为 protected 的类成员属性必须由下划线 “</em>” 作为开头；而声明为 public 的成员属性则在任何时候都不允许含有下划线。</li>
  <li>函数的命名使用小写字母和下划线的方式，且越详细越好，应该能够描述清楚该函数的功能，例如 get_client_ip 。</li>
  <li>当方法或函数参数不一定需要被赋值的时候，用 “null” 来代替 “false” 作为函数参数的默认值，除非该参数是 boolean 值。</li>
  <li>变量只允许由小写字母和下划线组成，且建议用描述性的变量的命名，越详细越好，以至于像 $i 或 $n 等等都是不鼓励使用的。</li>
  <li>类中的常量 constant 和全局范围内常量define，只能由大写字母和下划线组成，各个单词之间以下划线分割。</li>
  <li>boolean 值和 null 值都采用小写。</li>
</ol>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/04/macxia-pei-zhi-webkai-fa-huan-jing/">Macxia Pei Zhi Webkai Fa Huan Jing</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-04T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="phpjs">配置PHP和JS调试环境</h3>
<ul>
  <li>点击tools -&gt; build system -&gt; new build system</li>
  <li>
    <p>在其中输入如下代码，保存为PHP.sublime-build </p>

    <pre><code>  {
      "cmd": ["php", "$file"],
      "file_regex": "^(...*?):([0-9]*):?([0-9]*)",
      "selector": "source.php"
  }
</code></pre>
  </li>
  <li>此后，即可用command+B进行编译调试了</li>
</ul>

<p>另外，添加一个new build system，命名为JSC.sublime-build，添加以下内容，即可调试js代码：</p>

<pre><code>{
	"cmd": ["/System/Library/Frameworks/JavaScriptCore.framework/Versions/A/Resources/jsc", "$file"],
	"selector": "source.js"
}
</code></pre>

<hr />

<h3 id="xdebug">配置Xdebug</h3>

<h4 id="xdebug-1">安装xdebug</h4>

<p>选择一个xdebug版本</p>

<ul>
  <li>brew search xdebug</li>
</ul>

<p>安装xdebug</p>

<ul>
  <li>brew install php55-xdebug</li>
</ul>

<p>将以下代码片断加入到php.ini文件最后</p>

<pre><code>zend_extension= "/usr/lib/php/extensions/no-debug-non-zts-20121212/xdebug.so"
xdebug.default_enable = On
xdebug.show_exception_trace = On
xdebug.show_local_vars = 1
xdebug.max_nesting_level = 50
xdebug.var_display_max_depth = 6

xdebug.dump_once = On
xdebug.dump_globals = On
xdebug.dump_undefined = On
xdebug.dump.REQUEST = *
xdebug.cli_color = 2
</code></pre>

<p><strong>以下为配置sublime</strong></p>

<p>将项目保存为一个project</p>

<ul>
  <li>
    <p>sublime-&gt;project-&gt;save project as…</p>
  </li>
  <li>
    <p>利用package control 安装xdebug client</p>
  </li>
</ul>

<p>配置项目</p>

<ul>
  <li>sublime-&gt;project-&gt;edit project</li>
</ul>

<p>在其中添加类似以下内容</p>

<pre><code>{
    "folders":
    [
        {
            "follow_symlinks": true,
            "path": "."
        }
    ],
    "settings": {
        "xdebug": {
             "url": "http://my.local.website/",
        }
    }
}
</code></pre>

<p>开启调试，在项目文件中添加断点</p>

<ul>
  <li>xdebug-&gt;Add/Remove breakpoint</li>
</ul>

<p>进行调试</p>

<pre><code>tools-&gt;xdebug-&gt;start debugging(launch browser)
</code></pre>

</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/04/macxia-pei-zhi-nginx-plus-php-plus-mongokai-fa-huan-jing/">Macxia Pei Zhi Nginx Plus Php Plus Mongokai Fa Huan Jing</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-04T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4 id="brew">安装brew</h4>

<p>安装：</p>

<pre><code>curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/local --strip 1
</code></pre>

<p>brew安装的软件目录：</p>

<pre><code>/usr/local/Cellar
</code></pre>

<p>常用命令：</p>

<ul>
  <li>更新brew：brew update</li>
  <li>更新所有brew安装的软件：brew upgrade</li>
  <li>查看所有brew安装的软件：brew list</li>
  <li>搜索具体的程序包：brew search mysql</li>
  <li>安装具体的程序包：brew install mysql</li>
  <li>查看具体程序的信息：brew info mysql</li>
  <li>卸载具体的应用：brew uninstall mysql</li>
</ul>

<hr />

<h4 id="pecl">安装pecl</h4>

<pre><code>cd /usr/lib/php 
sudo php install-pear-nozlib.phar 
sudo pear channel-update pear.php.net 
sudo pecl channel-update pecl.php.net 
sudo pear upgrade-all
</code></pre>

<hr />

<h4 id="mongo">安装mongo</h4>

<p>安装</p>

<pre><code>brew install mongodb
</code></pre>

<p>创建/data/db文件夹，启动数据库需要</p>

<pre><code>sudo mkdir -p /data/db
</code></pre>

<p>启动数据库</p>

<pre><code>sudo mongod
</code></pre>

<p>命令行启动mongo操作终端(非必须)</p>

<pre><code>sudo mongo
</code></pre>

<p>停止数据库</p>

<pre><code>sudo pkill mongo
</code></pre>

<hr />

<h4 id="php">配置php</h4>

<p>由于mac自带有php，故直接使用系统自带的php</p>

<p>启动,若提示无相关文件，则创建相关文件再启动</p>

<pre><code>sudo php-fpm
</code></pre>

<p>配置文件路径</p>

<pre><code>/etc/php.ini
</code></pre>

<p>若无该配置文件，则创建该文件</p>

<pre><code>sudo mv /etc/php.ini.default /etc/php.ini
</code></pre>

<p>php扩展路径</p>

<pre><code>/usr/lib/php/extensions/
</code></pre>

<hr />

<h4 id="phpmongo">配置php的mongo扩展</h4>

<p>安装</p>

<pre><code>sudo pecl install mongo
</code></pre>

<p>在/etc/php.ini文档中最后添加</p>

<pre><code>extension=mongo.so
</code></pre>

<p>详细文档</p>

<p><a href="http://docs.mongodb.org/ecosystem/drivers/php/">PHP MongoDB Driver</a></p>

<hr />

<h4 id="nginx">安装nginx</h4>

<p>安装</p>

<pre><code>brew install nginx
</code></pre>

<p>启动</p>

<pre><code>sudo nginx
</code></pre>

<p>配置文件路径</p>

<pre><code>/usr/local/etc/nginx/nginx.conf
</code></pre>

<p>页面访问目录</p>

<pre><code>/usr/local/var/www
</code></pre>

<p>nginx常用命令</p>

<pre><code>nginx -V 查看版本，以及配置文件地址  
nginx -v 查看版本  
nginx -c filename 指定配置文件  
nginx -h 帮助  
nginx -s [reload\reopen\stop\quit]
</code></pre>

<p>详细配置教程</p>

<p><a href="http://oilbeater.com/nginx/2014/12/29/nginx-conf-from-zero.html">nginx配置从零开始</a></p>

<hr />

<h4 id="nginxphp">配置nginx支持php文件</h4>

<p>打开配置文档</p>

<p>sudo vim /usr/local/etc/nginx/nginx.conf</p>

<p>将监听端口更改80</p>

<pre><code>server {
        listen       80;
        server_name  localhost;
</code></pre>

<p>添加php解析支持，取消注释，并更改文件目录为/usr/local/var/www</p>

<pre><code>location ~ \.php$ {
            root           /usr/local/var/www;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  /usr/local/var/www$fastcgi_script_name;
            include        fastcgi_params;
        }
</code></pre>

<p><a href="http://huoding.com/2013/10/23/290">如何正确的配置nginx+php</a></p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/shan-yong-xcode%2Cti-gao-kai-fa-xiao-lu/">善用Xcode，提高开发效率</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T21:53:08+08:00" pubdate data-updated="true">May 11<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>　　默认的xcode其实已经很强大的了，用起来已经很贴心舒服了，但它还可以更加强大的，以下介绍下我自己的一些增强技巧。</p>

<p>　　<strong>一、配色</strong><br />
　　要提高效率，首先得看着舒服，是吧。默认的白色，平常使用其实也挺不错的了，但时间用长了，还是感觉有一些不舒服，它最大的问题是色彩对比不明显，不容易定位到关键词上去。我差不多是使用默认配色一年多后，才打算改换主题的，后来在网上下了很多别人的主题，都发觉要么是对比度太强烈了，看着刺眼，或者太花哨，或者太死板，都有一些不喜欢的地方。后来找到了一个相对比较喜欢的主题，这个主题是仿sublime的一个主题<a href="https://github.com/colinta/zenburn">zenburn</a> ，但还是有一些不太喜欢的地方，后来花了一整个下午，根据它调了一个主题，包括字体、背景色、关键词颜色等等，算是比较满意了，<a href="https://github.com/makeLaugh/xcodeTheme">下载链接</a>在这里，喜欢的拿走。<br />
　　安装方式：下载后，将主题文件放入<code>/Users/HZD/Library/Developer/Xcode/UserData/FontAndColorThemes </code>目录中，重启<code>xcode即可</code>。我的环境是xcode5.1，其它的未测试。</p>

<p>    <strong>二、CocoaPods</strong><br />
    对CocoaPods的介绍和安装教程网太多了，随便百度谷歌一下都满大街了，我想说，如果还没有使用它来管理毓三方库的，那得切换了，因为它实在是太简单太高效了。下面简单罗列一下使用步骤。 <a href="http://code4app.com/article/cocoapods-install-usage">详细参考教程</a></p>

<p>    <strong>更换ruby源</strong>，以加快安装速度，如果已经更换过的跳过：</p>

<pre><code>1. gem sources --remove https://rubygems.org/
2. gem sources -a http://ruby.taobao.org/
3. gem sources -l //查看新的镜像源
</code></pre>

<p>    安装ruby，一般mac都自带了ruby，若未安装，可用以下方式安装或更新到最新版  </p>

<pre><code>1. 安装RVM：curl -L https://get.rvm.io | bash -s stable --ruby
2. 列出已知的ruby版本：rvm list known
3. 安装最新的版本：rvm install version号
4. 切换到安装的版本上：rvm use version号
5. rvm rubygems latest
</code></pre>

<p>    安装和使用CocoaPods</p>

<pre><code>1. 安装CocoaPods：sudo gem install cocoapods
2. 搜索要使用的库：pod search AFNetworking，会得到如何使用、源地址等提示
3. 编辑配置文件：vim Podfile
4. 按上术提示，添加相关配置，并保存  
   platform :ios, '7.0'  
   pod "AFNetworking", "~&gt; 2.0"
5. 安装第三方库：pod install 
6. 以后打开项目都打开`.xcworkspace`文件，而不是源来的项目文件。
</code></pre>

<p>    就这样，安装完成了，以后就可以使用AFNetworking了。
    一个技巧：有时候，第三方库会有警告，为了忽略警告，只需要在Podfile文件中添加一个命令即可，<code>inhibit_all_warnings!</code>。
    以下我的Podfile配置文件作为一个参考：  </p>

<pre><code>platform :ios, '7.0'
inhibit_all_warnings!
pod 'MKNetworkKit'
pod 'FMDB', '~&gt; 2.2'
pod 'REFrostedViewController', '~&gt; 2.4.5'
pod 'BlocksKit'
pod 'Overline-BlocksKit'
pod 'Masonry'
pod 'AFNetworking', '~&gt; 2.2.3'
pod 'UIColor+CSSColors', '~&gt; 0.0.1'
pod 'BlurryModalSegue', '~&gt; 1.0.0'
pod 'SBAPNSPusher', '~&gt; 2.2.1'!
</code></pre>

<p>    伏笔，CocoaPod其实有更便捷的管理方式，见以下插件部分。</p>

<p>    <strong>三、插件</strong><br />
    Xcode已经是一个非常强大的IDE了，但是，它还可以更强大，这就需要外挂了。<br />
    首先，安装插件管理器，当然你也可以手动来管理，但是强列推荐使用它<a href="https://github.com/supermarin/Alcatraz"><strong>Alcatraz</strong></a>，有了它，你的xcode将无所不能，且极其的方便管理插件，安装卸载，一键搞定。详细教程，点开链接后仔细阅读吧，以下简单说明安装和卸载：<br />
    <strong>安装</strong>：curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh<br />
    或者下载源码编译即可<br />
    <strong>重启xcode</strong>，即可安装好<br />
    <strong>卸载</strong>：我还没有卸载过，你要不喜欢，运行下面的命令吧  </p>

<pre><code>卸载Alcatraz: rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin
卸载通过它安装的插件: rm -rf ~/Library/Application\ Support/Alcatraz/
</code></pre>

<p>    启动Alcatraz：<code>command+shift+9</code>或者window-&gt;Package Manager<br />
    它有四个菜单，分别为<strong>All 插件  主题  模板</strong>，点击单个插件前面的小图标时，会自动安装，安装成功后，注意看图标，变成了淡蓝色(注意睁大眼睛看)，卸载再点一次即可，更新再点一次就是更新了。</p>

<p>    网上已经有了各种排名的xcode的十大插件、十五大插件的，试用了一下，下面简单介绍几个个人使用后，觉得挺不错的插件：  </p>

<p>    1.<strong>CocoaPods</strong><br />
    不喜欢使用命令行？没关系，装上这个插件，在Product选项里，就集成了CocoaPods选项了，直接点击就可以在Xcode里管理CocoaPods里的第三方库了。<br />
    <img src="https://github.com/kattrali/cocoadocs-xcode-plugin/raw/master/menu.png" alt="image" /></p>

<p>    2.<strong>ColorSense</strong><br />
    是不是每次设置颜色的时候，不知道效果？用它吧，直接在代码里修改颜色，如下图：<br />
    <img src="/images/blog/2014/Xcode效率/ColorSense.png" alt="image" /></p>

<p>    3.<strong>VVDocumenter</strong><br />
    注释对于代码很重要，特别是对代码规范要求很严的公司，那更是必须写的，话说，自己写，有一个好的规范不也挺好的么，这个配合<code>appledoc</code>一起工作，简直是神器，下面有介绍。这货可以让你在写注释的时候，大幅的降低繁杂重复的工作量。见下图：<br />
    <img src="https://raw.github.com/onevcat/VVDocumenter-Xcode/master/ScreenShot.gif" alt="image" /></p>

<p>    4.<strong>FuzzyAutocomplete</strong><br />
    xcode自带的自动代码匹配功能不是很完善，当你只大概记得一个方法时，这时候，xcode就无能为力了，它登场了，效果见下图：<br />
    <img src="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin/raw/master/demo.gif" alt="image" /></p>

<p>    5.<strong>XAlign</strong><br />
    你有没有一个空格一个空格的敲，就为了对齐那该死的<code>@、=、*</code>等符号？好吧，如果你没有，那说明你没有代码洁癖，我应该恭喜你呢，还是替后来维护的人难受？<br />
    <img src="https://camo.githubusercontent.com/7973c0e352b1f91e3efe5b3550cff5df97f4589a/687474703a2f2f7166692e73682f58416c69676e2f696d616765732f657175616c2e676966" alt="image" /><br />
    <img src="https://camo.githubusercontent.com/f61bfc31e144ad6a9d7ca26fa19547a3af5da8c6/687474703a2f2f7166692e73682f58416c69676e2f696d616765732f646566696e652e676966" alt="image" /></p>

<p>    6.<strong>BBUDebuggerTuckAway</strong><br />
    xcode很强大，但有的时候，它却不太讨人喜欢，我明明在编写代码了，调试窗口却死活不肯退场，死占着那个位置，让我多难受啊。控制台，我开始写代码了，你去睡一会儿吧。<br />
    <img src="http://cms.csdnimg.cn/article/201405/05/53674c667516f.jpg" alt="image" /></p>

<p>    7.<strong>XcodeBoost</strong><br />
    它的使用有一点小复杂，你需要花一点时间去熟悉它，了解它，别恐惧，其实也没有那么复杂了，它真的很强大，真的非常的强大，有图有真相<br />
    <img src="https://github.com/fortinmike/XcodeBoost/raw/master/Images/highlighting.gif" alt="image" /><br />
    <img src="https://github.com/fortinmike/XcodeBoost/raw/master/Images/copy-method-declarations.gif" alt="image" /><br />
    <img src="https://github.com/fortinmike/XcodeBoost/raw/master/Images/paste-without-reindent.gif" alt="image" /><br />
    
    8.<strong>KSImagedNamed</strong>
    当我第一次看到它的时候，我内牛满面，我为什么不早点认识它呢，以前在代码里设置图片，不知道图片是什么样子，也不知道图片是什么名字的时候，在UI给我的图片包里，一个一个去找的时候，我有想疯了的感觉。这货不但可以自动匹配识别图片名字，还能预览图片，你还有什么理由不使用它呢？<br />
    <img src="http://cms.csdnimg.cn/article/201405/05/53673f77a65a3.jpg" alt="image" />    </p>

<p>    以上是我使用过后，感觉非常不错，能够极大提高效率的几个插件，以后有新的体验了，还会更新，这些插件都可以直接通过<code>Alcatraz</code>来管理，所以不上链接了。另声明：以上截图大部分来源于原作者网站。</p>

<p>    <strong>四、文档生成工具Appledoc</strong><br />
    前面介绍了<code>VVDocumenter</code>，终于轮到它登场了，使用<code>VVDocumenter</code>写上标准的注释，然后使用appledoc，一键生成苹果官方式的文档，如下图所示：<br />
	<img src="images/blog/2014/Xcode效率/appledoc1.png" alt="image" />  </p>

<p>    首先安装，可以选择正常安装，也可以选择homebrew安装。<br />
    <strong>正常安装</strong>：  </p>

<pre><code>1. git clone git://github.com/tomaz/appledoc.git
2. cd ./appledoc
3. sudo sh install-appledoc.sh
</code></pre>

<p>    <strong>homeBrew安装</strong>：  </p>

<pre><code>brew install appledoc
</code></pre>

<p>    <strong>使用：</strong>  </p>

<pre><code>1. cd 项目目录
2. appledoc -o ./doc --project-name MyProject --project-company MyCompany --company-id companyId .
</code></pre>

<p>    首先进入项目目录，然后运行上面的命令，<code>MyProject</code>是你项目的名字，<code>MyCompany</code>是你公司的名字，最后<code>./doc</code>是指在当前目录下，生成一个doc目录，里面有一个<code>docset-installed.txt</code>文件，里面记录你安装的记录和文档生成的路径，<code>companyId</code>一般写成<code>com.company</code>格式。<br />
    appledoc支持markdown、html等语言来写注释，详细的介绍推荐看<a href="http://blog.ibireme.com/2013/08/26/appledoc-guide/">这篇文章</a></p>

<p>    <strong>总结：</strong><br />
    Xcode虽然是苹果一家开发维护，封闭的，但是在配合一些其它的工具，还是可以极大的提高我们的开发效率，工欲善其事，必先利其器，好好的挖掘它的潜力，为我们服务！</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/gitjian-dan-shi-yong-cao-zuo/">Git简单实用操作</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T12:00:04+08:00" pubdate data-updated="true">May 11<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>总则：</strong>  </p>

<pre><code>1.多使用分支操作，体会git强大的分支功能。
2.在创建代码仓库的时候，默认会创建一个master分支，这个分支做为一个稳定分支，只合并稳定的代码。
3.另外创建一个dev分支，这个分支做为日常的开发测试使用，dev分支测试稳家后，方合并到master分支去。
4.如果需要开发计划外的功能时，可基于当前的开发分支，创建一个feature分支，完成后如果需要则合并到dev分支，如无需再使用则可删除。
5.如果遇到bug需要紧急修复，则可基于master分支创建fixed分支，修复完成测试通过，则合并到master分支，删除fixed分支。
</code></pre>

<p><strong>本地操作</strong></p>

<ul>
  <li>初始化：git init</li>
  <li>添加所有修改文件到git仓库：git add -A</li>
  <li>添加某单个文件到git仓库：git add 文件件</li>
  <li>确认修改内容：git commit -m “修改内容叙述”</li>
</ul>

<p><strong>与服务器相连</strong></p>

<ul>
  <li>克隆一个仓库：git clone 远端地址</li>
  <li>查看连接的远端地址：git remote -v</li>
  <li>连接到远端服务器：git remote add origin 远端地址</li>
  <li>与远端服务器断开连接：git remote rm origin</li>
  <li>将远端代码合并到本地：git pull origin master</li>
  <li>将本地代码上传到远端服务器：git push origin master</li>
</ul>

<p><strong>分支与合并</strong></p>

<ul>
  <li>查看分支：git branch -a</li>
  <li>基于当前分支创建分支并切换到新的分支：git checkout -b 分支名</li>
  <li>当前在master分支，将dev分支合并到master：git merge dev</li>
  <li>删除本地分支：git branch -d 分支名</li>
  <li>删除远端分支：
    <ul>
      <li>1.git push origin –delete 分支名  </li>
      <li>2.git push origin :分支名 //用空分支覆盖远端分支方式 </li>
    </ul>
  </li>
  <li>克隆远端某个分支：git checkout –track -b foobar origin/foobar</li>
  <li>提交本地的test分支到远端的master分支：git push origin test:master</li>
  <li>提交本地的test分支作为远端的test分支：git push origin test:test</li>
</ul>

<p><strong>查看状态</strong></p>

<ul>
  <li>查看当前哪些文件更改了而没有添加到仓库跟踪：git status</li>
  <li>查看历史提交记录：git log</li>
</ul>

<p><strong>版本回溯</strong></p>

<p>  <em>为了安全起见，最好基于所在分支创建一个分支，回到历史版本，找到需要的代码，然后再删除该分支。</em></p>

<ul>
  <li>在当前分支新建分支：git checkout -b 分支名</li>
  <li>查看历史提交记录，找到提交记录id：git log</li>
  <li>回到需要的历史版本：git checkout commitId</li>
  <li>找到需要的代码，复制出来，切换回原分支，删除该分支</li>
</ul>

</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/ren-sheng-ji-xu-shi-yi/">人生几许失意</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T20:01:19+08:00" pubdate data-updated="true">May 9<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今年的季后赛首轮，是我看得最多的一年，或许也会是我看过的最精彩的一次。相比第二轮的乏善可陈，这一轮可谓之精彩迭出; 可是在精彩落幕之后，在前进的道路上，总会落下落寞的身影。  </p>

<p>在成功者面前，在掌声欢呼中，失意者永远是被忽略的，但，高富帅，你的精彩的人生才刚开始，下个赛季期待你的更进一步。<br />
  <img src="/images/blog/2014/人生几许失意/1.jpg" alt="link" />  </p>

<p>从魔术到湖人，再从湖人到火箭，人生起伏太大，很多人说，你颠峰已过，但季后赛，你展现出一你一直以来的努力，篮球是一部分，生活永远是快乐的！<br />
  <img src="/images/blog/2014/人生几许失意/2.jpg" alt="link" />  </p>

<p>从落榜生到被裁到再上岗再到林疯狂，你的人生已足够精彩，从首发到替补，在质疑中，始终努力奉献着不太稳定的贡献，0.9s，是你不敢相信的表情，你不相信你们一个赛季的努力就这样结束了。虽然状态不太好，但始终努力着，下个赛季，相信你会更好。<br />
  <img src="/images/blog/2014/人生几许失意/3.jpg" alt="link" />  </p>

<p>  你们的时代已经结束了，但你们已经赢得了所有人的尊重，包括你们的对手<br />
  <img src="/images/blog/2014/人生几许失意/4.jpg" alt="link" />  </p>

<p>你的时代才刚开始，明年会更好，更进一步的<br />
  <img src="/images/blog/2014/人生几许失意/5.jpg" alt="link" />    </p>

<p>你们让所有人知道了你们的实力，没有超级球星，但你们有的是其它团队所没有的凝聚力和执行力，可惜你们赛季初的伤病，让遇到的了可能是十年难得一遇的天赋团队，下个赛季不知道你们还能不能再聚一起，希望可以！<br />
  <img src="/images/blog/2014/人生几许失意/6.jpg" alt="link" />  </p>

<p>年轻没有失败，努力，加油，明年再来<br />
  <img src="/images/blog/2014/人生几许失意/7.jpg" alt="link" />  </p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/centos6-dot-4pei-zhi-nginx-plus-php-plus-mongofu-wu-qi-huan-jing/">centos6.5配置nginx+php+mongo服务器环境</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T13:56:34+08:00" pubdate data-updated="true">May 9<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先系统安装完成后，执行：<code>yum -y update</code> 命令，升级补丁。</p>

<hr />

<h2 id="php54">安装PHP5.4</h2>

<p><a href="http://www.iitshare.com/centeros-6-3-64-bit-install-php-5-4-3.html">参考教程</a></p>

<p><strong>1.安装支持套件</strong></p>

<pre><code>yum -y install gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers
</code></pre>

<p><strong>2.安装支持库</strong></p>

<ul>
  <li><a href="http://pan.baidu.com/share/link?shareid=2787262895&amp;uk=553700327&amp;fid=2190701233">pcre-8.30.tar.gz下载</a></li>
  <li><a href="http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gz">libiconv-1.14.tar.gz下载</a></li>
  <li><a href="http://centos.googlecode.com/files/libmcrypt-2.5.8.tar.gz">libmcrypt-2.5.8.tar.gz下载</a></li>
  <li><a href="http://nchc.dl.sourceforge.net/project/mhash/mhash/0.9.9.9/mhash-0.9.9.9.tar.gz">mhash-0.9.9.9.tar.gz下载</a></li>
  <li>
    <p><a href="http://nchc.dl.sourceforge.net/project/mcrypt/MCrypt/2.6.8/mcrypt-2.6.8.tar.gz">mcrypt-2.6.8.tar.gz下载</a></p>

    <pre><code> 安装方法：
 tar zxvf 文件名.tar.gz
 cd 文件夹
 ./configure
 make install
</code></pre>
  </li>
</ul>

<p><strong>备注：</strong></p>

<pre><code>配置mcrypt-2.6.8.tar.gz支持库时出现以下错误
configure: error: *** libmcrypt was not found
解决方法
运行 export LD_LIBRARY_PATH=/usr/local/lib: LD_LIBRARY_PATH
然后编译执行

# ./configure
# make
# make install
</code></pre>

<p><strong>3.安装PHP5.4</strong></p>

<p><strong><a href="http://am1.php.net/get/php-5.4.26.tar.gz/from/this/mirror">下载地址</a></strong></p>

<p><strong>安装方法：</strong></p>

<pre><code>tar jvxf php-5.4.26.tar.gz
cd php-5.4.26
./configure -prefix=/usr/local/php -with-config-file-path=/usr/local/php/etc -with-iconv-dir=/usr/local/lib -with-freetype-dir -with-jpeg-dir -with-png-dir -with-zlib -with-libxml-dir=/usr -enable-xml -disable-rpath -enable-bcmath -enable-inline-optimization -with-curl -with-curlwrappers -enable-fpm -enable-mbstring -with-mcrypt -with-gd -enable-gd-native-ttf -with-openssl -with-mhash -enable-pcntl -enable-sockets -with-xmlrpc -enable-soap -without-pear -with-fpm-user=www -with-fpm-group=www --disable-fileinfo
make
make install
</code></pre>

<p><strong>备注：</strong></p>

<ul>
  <li>若./configure…时，报：<code>configure: error: Cannot find ldap libraries in /usr/lib</code>错误，则执行：<code>cp -frp /usr/lib64/libldap* /usr/lib/</code> 命令，再<code>./configure</code></li>
  <li>若make时报<code>make: *** [sapi/cli/php] Error 1</code>错误，则执行：先<code>make clean</code>后 再<code>make ZEND_EXTRA_LIBS='-liconv'</code> 命令</li>
  <li>若<code>make ZEND_EXTRA_LIBS='-liconv'</code>时报<code>make: *** [ext/phar/phar.php] 错误 127</code>，则。。。</li>
  <li>最后make install</li>
</ul>

<p><strong>添加配置文件：</strong></p>

<p>在安装文件目录，执行以下命令：</p>

<ul>
  <li>cp php.ini-production /usr/local/php/lib/php.ini</li>
  <li>cp php.ini-production /usr/local/php/etc/php.ini</li>
  <li>cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf</li>
</ul>

<p>编辑php-fpm.conf文件为以下内容：</p>

<pre><code>[global]
pid = run/php-fpm.pid
error_log = log/php-fpm.log
log_level = notice
[www]
listen = 127.0.0.1:9000
user = www
group = www
pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3
pm.max_requests = 500
</code></pre>

<p>测试php-fpm配置：</p>

<pre><code>/usr/local/php/sbin/php-fpm -t
如果显示以下信息，则说明安装成功
NOTICE: configuration file /usr/local/php/etc/php-fpm.conf test is successful
</code></pre>

<p>启动9000端口号</p>

<pre><code>防火墙中开启php默认的端口号9000，如果服务器没有开启防火墙，则不需要
</code></pre>

<p>启动php-fpm：</p>

<pre><code>/usr/local/php/sbin/php-fpm
如果启动报错：ERROR: [pool www] cannot get uid for user ‘www’
增加用户即可,具体的代码：useradd www -M -s /sbin/nologin
</code></pre>

<hr />

<h2 id="nginx">安装NGINX</h2>

<p><a href="http://nginx.org/packages/centos/6/x86_64/RPMS/nginx-1.4.6-1.el6.ngx.x86_64.rpm">下载地址</a></p>

<p><a href="http://nginx.org/packages/centos/6/x86_64/RPMS/nginx-1.4.6-1.el6.ngx.x86_64.rpm">nginx官方源库</a>：可以找寻其他版本</p>

<p>安装：</p>

<pre><code>rpm -ivh nginx-release-centos-6-0.el6.ngx.noarch.rpm
</code></pre>

<hr />

<h2 id="mongodb">安装Mongodb</h2>

<p><strong>1.添加yum源：</strong></p>

<pre><code>vi /etc/yum.repos.d/10gen.repo
添加以下语句：

[10gen] 
name=10gen Repository 
baseurl=http://downloads-distro.mongodb.org/repo/redhat/os/x86_64 
gpgcheck=0 
</code></pre>

<p><strong>2.安装MongoDB的服务器端和客户端工具：</strong></p>

<pre><code>yum install mongo-10gen-server
yum install mongo-10gen
</code></pre>

<p>3.更新Mongodb：</p>

<pre><code>停掉mongodb，执行
yum update mongo-10gen mongo-10gen-server
</code></pre>

<p>备注：也可到<a href="http://downloads-distro.mongodb.org/repo/redhat/os/x86_64">这里</a>下载最新版，手动<code>yum -ivh ...</code>安装。需要先安装mongo-10gen，再安装mongo-10gen-server。</p>

<p>启动Mongodb：service mongod start</p>

<hr />

<p><strong>以上将三个库都安装完成了，下面需要装三个关联起来。</strong></p>

<p><strong>首先配置NGINX，支持PHP解析</strong></p>

<p>1.打开/etc/nginx/conf.d目录下的default.conf文件。<br />
2.如下代码所示，将<code>location</code> 中的相关路径保持一致，差添加index.php解析</p>

<pre><code>server {
listen       80;
server_name  localhost;

#charset koi8-r;
#access_log  /var/log/nginx/log/host.access.log  main;

location / {
    root   /usr/share/nginx/html;
    index  index.php index.html index.htm;
}

#error_page  404              /404.html;

# redirect server error pages to the static page /50x.html
#
error_page   500 502 503 504  /50x.html;
location = /50x.html {
    root   /usr/share/nginx/html;
}

# proxy the PHP scripts to Apache listening on 127.0.0.1:80
#
#location ~ \.php$ {
#    proxy_pass   http://127.0.0.1;
#}

# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
#
location ~ \.php$ {
    root           /usr/share/nginx/html;
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    fastcgi_param  SCRIPT_FILENAME  /usr/share/nginx/html$fastcgi_script_name;
    include        fastcgi_params;
}

# deny access to .htaccess files, if Apache's document root
# concurs with nginx's one
#
#location ~ /\.ht {
#    deny  all;
#}
</code></pre>

<h5 id="phpmongodb">安装PHP对Mongodb的驱动</h5>

<p>1.<strong><a href="http://github.com/mongodb/mongo-php-driver">下载驱动</a></strong></p>

<p>2.<strong>解压，并进入到该目录。</strong></p>

<p>3.执行以下命令：</p>

<pre><code>phpize		或者  /usr/local/php/bin/phpize 
./configure	或者  ./configure  --with-php-config=/usr/local/php/bin/php-config --with-mongodb 
make all
sudo make install
</code></pre>

<p>4.编辑php配置文件，添加对mongodb的支持</p>

<pre><code>vim /usr/local/php/etc/php.ini

在最后添加如下代码：

extension=mongo.so

保存退出
</code></pre>

<h5 id="mongodb-administrator">安装MongoDB Administrator</h5>

<p>1.<a href="http://rockmongo.com/downloads">下载地址</a></p>

<p>2.将文件解压到 <code>/usr/share/nginx/html</code> 文件夹里</p>

<p>3.在浏览器里打开：http://localhost/rockmongo/index.php</p>

<p>4.初始密码：admin admin</p>

<p>5.若添加管理员后，去除默认管理员，需要打开rockmogo里的配置文件，将其中一行改为：</p>

<pre><code>vim /usr/share/nginx/html/rockmongo/config.php

$MONGO["servers"][$i]["mongo_auth"] = true;//enable mongo authentication?
</code></pre>

<hr />

<p>至此，已全部配置完毕，在配置完成后，需要重新启动服务。</p>

<p><strong>以下是几个常用命令</strong></p>

<pre><code>* 启动NGINX：service nginx start
* 停步NGINX：service nginx stop
* 重启NGINX：service nginx reload


* 启动PHP： /usr/local/php/sbin/php-fpm
* 停止PHP：killall -9 php-fpm

* 启动Mongo：service mongod start
* 停止Mongo：service mongod stop
</code></pre>

<p><strong>相关配置文件所在目录：</strong></p>

<pre><code>* nginx 配置文件目录：/etc/nginx/*.conf
* php配置文件目录：/usr/local/php/etc/php.ini
* 网页文件目录：/usr/share/nginx/html 
</code></pre>

</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/14/mknetworkenginede-%5B%3F%5D-ceng-xiao-feng-zhuang/">MKNetworkEngine的一层小封装</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-14T13:33:09+08:00" pubdate data-updated="true">Feb 14<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>    之前使用ASI做网络请求的时候，也会对ASI做一层薄薄的封装，以提高代码实际使用时的利用率，后来切换成MKNetworkEngine的时候，也做了一层小封装，现共享如下，<a href="https://github.com/makeLaugh/TWAPP">示例代码</a>在这个目录里：AppGeneral/AppEngine/TWModel/TWNetworkRequest.h里。</p>

<p>    在<strong>TWNetworkRequest.h</strong>头文件里:</p>

<p>    首先声明成功和失败的两个Block：</p>

<pre><code>//成功失败Blocks
typedef void (^TWFinishedBlock) (NSDictionary *data);
typedef void (^TWFailedBlock)   (NSString *error);
</code></pre>

<p>    其次设置网络请求方式，默认为POST</p>

<pre><code>@interface TWNetworkRequest : NSObject
//网络请求方式，默认为POST
@property (copy, nonatomic) NSString *httpMethod;
</code></pre>

<p>    下面是几个具体的网络请求接口</p>

<p>    最基础的一个接口，用得最多的情况</p>

<pre><code>//请求数据接口
- (void)requestDataWithParams:(NSDictionary *)params
                      forPath:(NSString *)path
                     finished:(TWFinishedBlock)finished
                       failed:(TWFailedBlock)failed;
</code></pre>

<p>    可以上传Image的一个接口，相对来说用得没有那么多</p>

<pre><code>- (void)requestDataWithParams:(NSDictionary *)params
                    withImage:(UIImage *)image
                     imageKey:(NSString *)imageKey
                    imageName:(NSString *)imageName
                      forPath:(NSString *)path
                     finished:(TWFinishedBlock)finished
                       failed:(TWFailedBlock)failed;
</code></pre>

<p>    上传和下载文件</p>

<pre><code>//下载文件,hostName为主站点名。
- (void)downloadFileWithFilePath:(NSString *)filePath
                        hostName:(NSString *)hostName
                      toSavePath:(NSString *)savePath
                        finished:(TWFinishedBlock)finished
                          failed:(TWFailedBlock)failed;

//上传文件，path为要上传的接口，fileKey为后台设定的关键字，fileName为自行设定的文件名。
- (void)upLoadFile:(NSData *)fileData
          hostName:(NSString *)hostName
              path:(NSString *)path
           fileKey:(NSString *)fileKey
          fileName:(NSString *)fileName
          finished:(TWFinishedBlock)finished
            failed:(TWFailedBlock)failed;
</code></pre>

<p>    这里的部分是需要注意的，接口参数没什么问题，主要是我定义的几个变量如<code>TWSucceed</code>、<code>code</code>等这些，可能各人的不一样，这些一般是由后台定义的东西，相应的替换掉即可。</p>

<pre><code>- (void)requestDataWithParams:(NSDictionary *)params
                    withImage:(UIImage *)image
                     imageKey:(NSString *)imageKey
                    imageName:(NSString *)imageName
                      forPath:(NSString *)path
                     finished:(TWFinishedBlock)finished
                       failed:(TWFailedBlock)failed
{
    MKNetworkEngine *networkEngine = appDelegate().networkEngine;
    MKNetworkOperation *operation = [networkEngine operationWithPath:path
                                                              params:params
                                                          httpMethod:self.httpMethod];
    if (image)
    {
        NSData *imageData = UIImageJPEGRepresentation(image, 1);
        NSString *mimeType = [NSData contentTypeForImageData:imageData];
        [operation addData:imageData forKey:imageKey mimeType:mimeType fileName:imageName];
    }
    [operation addCompletionHandler:^(MKNetworkOperation *completedOperation)
     {
         NSData *data = [completedOperation.responseString dataUsingEncoding:NSUTF8StringEncoding];
         NSDictionary *resultDict = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];         
         if (completedOperation.HTTPStatusCode == 200)
         {
             if ([resultDict[@"code"] integerValue] == TWSucceed)
             {
                 finished(resultDict);
             }
             else if ([resultDict[@"code"] integerValue] == TWNeedLogin)
             {
                 failed(resultDict[@"msg"]);
                 [mNotificationCenter postNotificationName:kReLoginNotification object:nil];
             }
             else if ([resultDict[@"code"] integerValue] == TWNoData)
             {
                 failed(resultDict[@"msg"]);
             }
             else if ([resultDict[@"code"] integerValue] == TWFailed)
             {
                 failed(resultDict[@"msg"]);
             }
             else
             {
                 failed(resultDict[@"msg"]);
             }
         }
         else
         {
             failed(resultDict[@"msg"]);
         }
     }
                       errorHandler:^(MKNetworkOperation *completedOperation, NSError *error)
     {
         mAlertView(@"网络错误", error.localizedDescription);
     }];
    [networkEngine enqueueOperation:operation];
}
</code></pre>

<p>    具体实现就不贴了，看我给的链接里的示例吧，这只是我针对自己的项目的一点简单封装，以我的要求来实现的，仅作参考吧！</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/27/iosxiang-mu-jia-gou-tan-suo/">iOS项目架构探索</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-27T10:28:48+08:00" pubdate data-updated="true">Jan 27<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>    做了iOS项目两年多，对怎么来做好项目架构，做过一些思考，也参考了一些别人的写法，这里写下自己的一些想法与思考，在我的github上面有<a href="https://github.com/makeLaugh/TWAPP">示例代码</a>。</p>

<h4 id="section">首先来看项目在硬盘上的实际目录结构</h4>

<p><img src="/images/blog/2014/iOS项目架构探索/1.png" alt="实体目录结构" /></p>

<p>    在这里，我给每个功能块，都建立实际的目录文件夹来管理，每个功能块里，都建立三个文件夹：Controller、Model、View，这样做，主要是让整个目录结构很清晰，易于管理。	</p>

<h4 id="xcode">再来看看在Xcode中的目录结构</h4>

<p><img src="/images/blog/2014/iOS项目架构探索/2.png" alt="整个项目目录" /></p>

<p>    在Xcode里，整体目录结构和实体文件夹结构保持一致。</p>

<h4 id="lib">项目里的Lib目录</h4>

<p><img src="/images/blog/2014/iOS项目架构探索/3.png" alt="Lib目录" /></p>

<p>    主要用于管理第三方类库，比如我这里添加了FMDB、MKNetworkKit、SDWebImage等几个常用的类库，还有Category里主要是用来管理自己写的一些常用分类; Views管理一些常用的第三方类库。</p>

<h4 id="app">这里是APP真正的结构了，写代码最多的地方</h4>

<p><img src="/images/blog/2014/iOS项目架构探索/4.png" alt="APP代码目录" /></p>

<ul>
  <li>Controller：放各种ViewController，实现逻辑控制，为了缩短类名，我ViewController都缩写为VC</li>
  <li>View：管理ViewController的各个子View</li>
  <li>Model：数据模型文件夹，各种数据模型都放在里面，如果简单的Controller，可能不需要</li>
</ul>

<h4 id="app-1">这里是很多APP都可以通用的一个目录，需要做的修改很少，很多甚至直接拖进去都可以直接使用的</h4>

<p><img src="/images/blog/2014/iOS项目架构探索/5.png" alt="AppGeneral目录" /></p>

<p>AppGeneral分为两个目录：AppDefine和AppEngine</p>

<ul>
  <li>AppDefine：这里管理一些常用的定义
    <ul>
      <li>Appconfig.h：定义了项目里一些常用的常量，比如常用的字体、颜色、常量等等</li>
      <li>MacroDefine.h：定义一通用的一些宏定义，所有项目通用，以m开头</li>
      <li>NetworkAPI.h：定义项目里的网络接口</li>
    </ul>
  </li>
  <li>AppEngine:这里定义了一些通用的数据模型和UI
    <ul>
      <li>TWModel：定义了一些通用的数据模型
        <ul>
          <li>TWModel.h：模型的引入头文件，方便引用</li>
          <li>TWTableDataSource.h：定义TableView的通用DataSource，以减轻使用UITableView的VC复杂度</li>
          <li>TWTableDelegate.h：定义TableView的通用Delegate，以减轻使用UITableView的VC复杂度</li>
          <li>TWTableModel.h：TableView的通用数据模型，对TableView的数据做简单的处理</li>
          <li>TWNetworkRequest.h：对MKNetworkEngine的一层封装，简化网络请求</li>
        </ul>
      </li>
      <li>TWUIKit:定制项目里一些通用的UI样式，这样在具体使用的时候，就不需要再单独进行设置，这里的设置可能每个项目都需要自行根据需求设定
        <ul>
          <li>TWKit.h：UI的引入头文件，方便引用</li>
          <li>TWButton.h：定制Button的样式，如形状，字体大小等等</li>
          <li>TWCell.h：定制Cell的几个通用方法，配合TWTableDataSorce和TWTableDelegate使用</li>
          <li>TWLable：定义Label，如背景为透明，字体大小等</li>
          <li>TWTextField：定制TextField，如圆角，字体大小，背景色等</li>
          <li>TWTextView：同上</li>
          <li>TWViewController.h：定制ViewController，如显示加载页面等</li>
          <li>TWBarButtonItem.h：定制BarButtonItem按钮，如导航栏按钮，在iOS7和之前显示是不一样的，这里把它设置为一样的，使样式统一，体验一致</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="pch">最后来看.pch文件引用</h4>
<p><img src="/images/blog/2014/iOS项目架构探索/6.png" alt="PCH文件" /></p>

<p>    这里我把一些常用的基本上不会改变的、可能会在很多地方都使用到的头文件，一次在这个文件里引用，这样就不会每次使用的时候，都去引入一次了。</p>

<h3 id="section-1">总结一下</h3>
<p>    我觉得，项目架构，最主要的是要使项目结构清晰，易于管理，然后是简化开发。所以我首先把项目文件夹规范起来，定义各个文件夹的作用，这是为了文件管理，使结构清晰。然后，定义一些通用的模板和全局样式，这样就不至于写很多重复的代码，简化开发。</p>

<p>    另外，这里面，其实有一些东西，是可以单独拿出来写一下，比如TWTableDataSource、TWTableDelegate和Views里的一些东西等等，后续再写。</p>
</div>
  
  

</article>

<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">文章归档</a></div>
</nav>
    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - makeLaugh -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  














</body>
</html>
